// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/app_api.dart';
import 'api/channel_api.dart';
import 'api/chat_api.dart';
import 'api/contacts_api.dart';
import 'api/conversation_id_util.dart';
import 'api/download_api.dart';
import 'api/emotion_api.dart';
import 'api/group_api.dart';
import 'api/login_api.dart';
import 'api/model/chat.dart';
import 'api/model/client_info.dart';
import 'api/model/contacts.dart';
import 'api/model/conversation.dart';
import 'api/model/ffi_channel_model.dart';
import 'api/model/ffi_download.dart';
import 'api/model/ffi_emotion_model.dart';
import 'api/model/ffi_init_params.dart';
import 'api/model/ffi_message_common.dart';
import 'api/model/ffi_message_content.dart';
import 'api/model/ffi_message_content_audio.dart';
import 'api/model/ffi_message_content_dice.dart';
import 'api/model/ffi_message_content_dynamic_image.dart';
import 'api/model/ffi_message_content_file.dart';
import 'api/model/ffi_message_content_game.dart';
import 'api/model/ffi_message_content_group_event.dart';
import 'api/model/ffi_message_content_html.dart';
import 'api/model/ffi_message_content_html2.dart';
import 'api/model/ffi_message_content_image.dart';
import 'api/model/ffi_message_content_location.dart';
import 'api/model/ffi_message_content_medias_caption.dart';
import 'api/model/ffi_message_content_name_card.dart';
import 'api/model/ffi_message_content_notice.dart';
import 'api/model/ffi_message_content_redpacket.dart';
import 'api/model/ffi_message_content_system.dart';
import 'api/model/ffi_message_content_text.dart';
import 'api/model/ffi_message_content_transfer.dart';
import 'api/model/ffi_message_content_unknown.dart';
import 'api/model/ffi_message_content_video.dart';
import 'api/model/ffi_message_model.dart';
import 'api/model/ffi_message_user.dart';
import 'api/model/group.dart';
import 'api/model/login.dart';
import 'api/model/user.dart';
import 'api/user_api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'pb/common.dart';
import 'pb/contacts.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => -44242447;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_openchat_client',
        ioDirectory: '../rust_lib_openchat_client/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiChatApiBatchDeleteConversations({
    required List<(FfiChatType, PlatformInt64)> conversationIds,
  });

  Future<void> crateApiChatApiBatchMarkConversationAsRead({
    required List<(FfiChatType, PlatformInt64)> conversationIds,
  });

  Future<void> crateApiEmotionApiClearEmoticonCache();

  Future<bool> crateApiContactsApiContactOperation({
    required ContactsOperator operation,
    required ContactsParam params,
  });

  Future<String> crateApiDownloadApiDecompressZipFile({
    required String inputPath,
    String? outputPath,
  });

  Future<String> crateApiDownloadApiDecompressZlibFile({
    required String inputPath,
    String? outputPath,
  });

  Future<void> crateApiChatApiDeleteConversation({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
  });

  Future<DownloadResult> crateApiDownloadApiDownloadFileEncryptedApi({
    required String baseUrl,
    required String endpoint,
    required String savePath,
    required bool autoUnzip,
    Map<String, String>? customHeaders,
    bool? extractToFolder,
  });

  Future<DownloadResult> crateApiDownloadApiDownloadFileHttp({
    required String url,
    required String savePath,
    required bool autoUnzip,
    Map<String, String>? customHeaders,
  });

  Future<DownloadResult> crateApiDownloadApiDownloadFileHttpEnhanced({
    required String url,
    required String savePath,
    required bool autoUnzip,
    Map<String, String>? customHeaders,
    required FileOverwritePolicy overwritePolicy,
    required bool calculateHash,
    bool? extractToFolder,
  });

  Future<List<DownloadResult>> crateApiDownloadApiDownloadFilesBatch({
    required List<DownloadTask> downloadTasks,
  });

  Future<List<DownloadResult>> crateApiDownloadApiDownloadFilesBatchEnhanced({
    required List<DownloadTaskEnhanced> downloadTasks,
  });

  Future<DownloadProgressInfo> crateApiModelFfiDownloadDownloadProgressInfoNew({
    required PlatformInt64 downloadedBytes,
    PlatformInt64? totalBytes,
    required double progressPercentage,
    required String url,
  });

  Future<FfiAnmatedMessageContent>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToJsonString({
    required FfiAnmatedMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToProtoData({
    required FfiAnmatedMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentGetFfiSubMsgType({
    required FfiAnmatedMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentJsonToFfi({
    required FfiAnmatedMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentProtoDecodeToJson({
    required FfiAnmatedMessageContent that,
    required List<int> content,
  });

  Future<FfiAudioMessageContent>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToJsonString({
    required FfiAudioMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToProtoData({
    required FfiAudioMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentGetFfiSubMsgType({
    required FfiAudioMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentJsonToFfi({
    required FfiAudioMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentProtoDecodeToJson({
    required FfiAudioMessageContent that,
    required List<int> content,
  });

  Future<FfiChatTransferMessageContent>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToJsonString({
    required FfiChatTransferMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToProtoData({
    required FfiChatTransferMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentGetFfiSubMsgType({
    required FfiChatTransferMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentJsonToFfi({
    required FfiChatTransferMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentProtoDecodeToJson({
    required FfiChatTransferMessageContent that,
    required List<int> content,
  });

  Future<FfiChatType> crateApiModelFfiMessageCommonFfiChatTypeFromI32({
    required int value,
  });

  Future<int> crateApiModelFfiMessageCommonFfiChatTypeToI32({
    required FfiChatType that,
  });

  Future<FfiCommonMessageModel>
  crateApiModelFfiMessageCommonFfiCommonMessageModelNew({
    required PlatformInt64 targetId,
    required FfiChatType chatType,
    required FfiMsgType msgType,
  });

  Future<FfiContactDetail> crateApiModelContactsFfiContactDetailFrom({
    required ContactsDetailBase detail,
  });

  Future<FfiDiceMessageContent>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToJsonString({
    required FfiDiceMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToProtoData({
    required FfiDiceMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentGetFfiSubMsgType({
    required FfiDiceMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentJsonToFfi({
    required FfiDiceMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentProtoDecodeToJson({
    required FfiDiceMessageContent that,
    required List<int> content,
  });

  Future<FfiDynamicImageMessageContent>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToJsonString({
    required FfiDynamicImageMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToProtoData({
    required FfiDynamicImageMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentGetFfiSubMsgType({
    required FfiDynamicImageMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentJsonToFfi({
    required FfiDynamicImageMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentProtoDecodeToJson({
    required FfiDynamicImageMessageContent that,
    required List<int> content,
  });

  Future<FfiFileMessageContent>
  crateApiModelFfiMessageContentFileFfiFileMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentFileFfiFileMessageContentFfiToJsonString({
    required FfiFileMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentFileFfiFileMessageContentFfiToProtoData({
    required FfiFileMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentFileFfiFileMessageContentGetFfiSubMsgType({
    required FfiFileMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentFileFfiFileMessageContentJsonToFfi({
    required FfiFileMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentFileFfiFileMessageContentProtoDecodeToJson({
    required FfiFileMessageContent that,
    required List<int> content,
  });

  Future<FfiGroupEventMessageContent>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToJsonString({
    required FfiGroupEventMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToProtoData({
    required FfiGroupEventMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentGetFfiSubMsgType({
    required FfiGroupEventMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentJsonToFfi({
    required FfiGroupEventMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<FfiGroupEventMessageContent>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentNew({
    required int rawMsgType,
    required List<int> content,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentProtoDecodeToJson({
    required FfiGroupEventMessageContent that,
    required List<int> content,
  });

  Future<FfiHtml2MessageContent>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToJsonString({
    required FfiHtml2MessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToProtoData({
    required FfiHtml2MessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentGetFfiSubMsgType({
    required FfiHtml2MessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentJsonToFfi({
    required FfiHtml2MessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentProtoDecodeToJson({
    required FfiHtml2MessageContent that,
    required List<int> content,
  });

  Future<FfiHtmlMessageContent>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToJsonString({
    required FfiHtmlMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToProtoData({
    required FfiHtmlMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentGetFfiSubMsgType({
    required FfiHtmlMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentJsonToFfi({
    required FfiHtmlMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentProtoDecodeToJson({
    required FfiHtmlMessageContent that,
    required List<int> content,
  });

  Future<FfiImageMessageContent>
  crateApiModelFfiMessageContentImageFfiImageMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentImageFfiImageMessageContentFfiToJsonString({
    required FfiImageMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentImageFfiImageMessageContentFfiToProtoData({
    required FfiImageMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentImageFfiImageMessageContentGetFfiSubMsgType({
    required FfiImageMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentImageFfiImageMessageContentJsonToFfi({
    required FfiImageMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentImageFfiImageMessageContentProtoDecodeToJson({
    required FfiImageMessageContent that,
    required List<int> content,
  });

  Future<FfiInitParams> crateApiModelFfiInitParamsFfiInitParamsDefault();

  Future<FfiLocationMessageContent>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToJsonString({
    required FfiLocationMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToProtoData({
    required FfiLocationMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentGetFfiSubMsgType({
    required FfiLocationMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentJsonToFfi({
    required FfiLocationMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentProtoDecodeToJson({
    required FfiLocationMessageContent that,
    required List<int> content,
  });

  Future<FfiMediasCaptionMessageContent>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToJsonString({
    required FfiMediasCaptionMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToProtoData({
    required FfiMediasCaptionMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentGetFfiSubMsgType({
    required FfiMediasCaptionMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentJsonToFfi({
    required FfiMediasCaptionMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentProtoDecodeToJson({
    required FfiMediasCaptionMessageContent that,
    required List<int> content,
  });

  Future<FfiMessageModel>
  crateApiModelFfiMessageModelFfiMessageModelCreateSendMessage({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required PlatformInt64 sendTime,
    FfiReferenceObj? refObj,
    required ArcFfiMessageContentTrait ffiContent,
  });

  Future<FfiMessageModel>
  crateApiModelFfiMessageModelFfiMessageModelFfiMessageFromProto({
    required FfiMessageMetaData metaData,
  });

  Future<PlatformInt64> crateApiModelFfiMessageModelFfiMessageModelGetTargetId({
    required FfiMessageModel that,
  });

  Future<FfiMessageUser>
  crateApiModelFfiMessageUserFfiMessageUserCurrentSender();

  Future<ArcFfiMessageContentTrait>
  crateApiModelFfiMessageContentFfiMsgContentGetContent({
    required FfiMsgContent that,
  });

  Future<FfiMsgType> crateApiModelFfiMessageCommonFfiMsgTypeDefault();

  Future<FfiMsgType> crateApiModelFfiMessageCommonFfiMsgTypeFromI32({
    required int value,
  });

  Future<int> crateApiModelFfiMessageCommonFfiMsgTypeToI32({
    required FfiMsgType that,
  });

  Future<FfiNameCardMessageContent>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToJsonString({
    required FfiNameCardMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToProtoData({
    required FfiNameCardMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentGetFfiSubMsgType({
    required FfiNameCardMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentJsonToFfi({
    required FfiNameCardMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentProtoDecodeToJson({
    required FfiNameCardMessageContent that,
    required List<int> content,
  });

  Future<FfiNoticeMessageContent>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToJsonString({
    required FfiNoticeMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToProtoData({
    required FfiNoticeMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentGetFfiSubMsgType({
    required FfiNoticeMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentJsonToFfi({
    required FfiNoticeMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentProtoDecodeToJson({
    required FfiNoticeMessageContent that,
    required List<int> content,
  });

  Future<FfiPushNotificationType>
  crateApiModelChatFfiPushNotificationTypeDefault();

  Future<FfiRedPacketMessageContent>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToJsonString({
    required FfiRedPacketMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToProtoData({
    required FfiRedPacketMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentGetFfiSubMsgType({
    required FfiRedPacketMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentJsonToFfi({
    required FfiRedPacketMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentProtoDecodeToJson({
    required FfiRedPacketMessageContent that,
    required List<int> content,
  });

  Future<FfiReferenceObj> crateApiModelFfiMessageCommonFfiReferenceObjDefault();

  Future<FfiSystemMessageContent>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToJsonString({
    required FfiSystemMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToProtoData({
    required FfiSystemMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentGetFfiSubMsgType({
    required FfiSystemMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentJsonToFfi({
    required FfiSystemMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentProtoDecodeToJson({
    required FfiSystemMessageContent that,
    required List<int> content,
  });

  Future<FfiTextMessageContent>
  crateApiModelFfiMessageContentTextFfiTextMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentTextFfiTextMessageContentFfiToJsonString({
    required FfiTextMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentTextFfiTextMessageContentFfiToProtoData({
    required FfiTextMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentTextFfiTextMessageContentGetFfiSubMsgType({
    required FfiTextMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentTextFfiTextMessageContentJsonToFfi({
    required FfiTextMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentTextFfiTextMessageContentProtoDecodeToJson({
    required FfiTextMessageContent that,
    required List<int> content,
  });

  Future<FfiUnknownMessageContent>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToJsonString({
    required FfiUnknownMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToProtoData({
    required FfiUnknownMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentGetFfiSubMsgType({
    required FfiUnknownMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentJsonToFfi({
    required FfiUnknownMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<FfiUnknownMessageContent>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentNew({
    required int rawMsgType,
    required List<int> content,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentProtoDecodeToJson({
    required FfiUnknownMessageContent that,
    required List<int> content,
  });

  Future<FfiVideoMessageContent>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentDefault();

  Future<String>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToJsonString({
    required FfiVideoMessageContent that,
  });

  Future<Uint8List>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToProtoData({
    required FfiVideoMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  });

  Future<FfiMsgType>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentGetFfiSubMsgType({
    required FfiVideoMessageContent that,
  });

  Future<void>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentJsonToFfi({
    required FfiVideoMessageContent that,
    required String uniKey,
    required String jsonStr,
  });

  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentProtoDecodeToJson({
    required FfiVideoMessageContent that,
    required List<int> content,
  });

  Future<ArcFfiMessageContentTrait>
  crateApiModelFfiMessageContentFindProcesser({required int msgTypeVal});

  Future<FfiEmoticonListResult> crateApiEmotionApiForceUpdateEmoticonList();

  Future<String> crateApiConversationIdUtilGenarateConversationId({
    required int chatTypeVal,
    required PlatformInt64 targetId,
  });

  Future<List<FfiConversation>> crateApiChatApiGetArchivedConversations();

  Future<FfiConversation?> crateApiChatApiGetArchivedGroup();

  Future<String> crateApiEmotionApiGetCacheInfo();

  Future<List<FfiChannelModel>> crateApiChannelApiGetChannelContactList();

  Future<FfiChannelModel?> crateApiChannelApiGetChannelDetail({
    required PlatformInt64 channelId,
  });

  Future<int> crateApiChannelApiGetChannelMemberCount({
    required String conversationId,
  });

  Future<List<FfiConversation>> crateApiChatApiGetChatConversations();

  Future<List<FfiMessageModel>> crateApiChatApiGetChatHistory({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required int limit,
    PlatformInt64? beforeId,
  });

  Future<List<FfiContactDetail>> crateApiContactsApiGetContactsList({
    required bool includePresences,
    required ContactOrderType orderType,
  });

  Future<String> crateApiConversationIdUtilGetConversationId({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
  });

  Future<List<FfiConversation>> crateApiChatApiGetConversationsWithArchived();

  Future<String?> crateApiDownloadApiGetDocumentsDirectoryPath();

  Future<FfiGetEmoticonResponse> crateApiEmotionApiGetEmoticonList();

  Future<FfiEmoticonListResult> crateApiEmotionApiGetEmoticonListAuto();

  Future<List<FfiAnimatedGameConfig>> crateApiEmotionApiGetGameGlobalConfig();

  Future<List<FfiGroupBase>> crateApiGroupApiGetGroupContactList();

  Future<FfiGroupDetailResponse> crateApiGroupApiGetGroupDetail({
    required PlatformInt64 groupId,
  });

  Future<int> crateApiGroupApiGetGroupMemberCount({
    required String conversationId,
  });

  Future<BigInt> crateApiEmotionApiGetLastUpdateTime();

  Future<void> crateApiLoginApiGetSmsCode({
    required String countryCode,
    required String phone,
  });

  Future<PlatformInt64>
  crateApiConversationIdUtilGetTargetIdFromConversationId({
    required String conversationId,
  });

  Future<FfiUser> crateApiUserApiGetUser({required PlatformInt64 uid});

  Future<bool> crateApiAppApiInitApp({
    required FfiClientInfo clientInfo,
    required FfiInitParams initParams,
    required PlatformInt64 uid,
  });

  Stream<String> crateApiAppApiInitLogger();

  Future<void> crateApiAppApiInitTableData();

  Future<bool> crateApiDownloadApiIsZipFile({required String filePath});

  Future<bool> crateApiDownloadApiIsZlibFile({required String filePath});

  Stream<String> crateApiDownloadApiListenForDownloadProgress();

  Stream<Rust2ClientMessagePayload> crateApiChatApiListenForMessages();

  Stream<FfiUser> crateApiUserApiListenForUserInfoUpdates();

  Future<FfiLoginResponse> crateApiLoginApiLogin({
    required String countryCode,
    required String phone,
    required String smsCode,
  });

  Future<FfiLoginResponse> crateApiLoginApiLoginByPassword({
    required String countryCode,
    required String phone,
    required String password,
  });

  Future<void> crateApiChatApiMarkConversationAsRead({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
  });

  Future<void> crateApiChatApiMarkMessageAsRead({required String msgId});

  Future<void> crateApiChatApiMarkSessionAsRead({
    required String conversationId,
  });

  Future<MessageError> crateApiModelFfiMessageContentMessageErrorNew({
    required String msg,
  });

  Future<String> crateApiDownloadApiNormalizeFilePath({required String path});

  Future<bool> crateApiContactsApiNotifyContactAction({
    required PlatformInt64 userId,
    required String action,
    required String params,
  });

  Future<(FfiChatType, PlatformInt64)>
  crateApiConversationIdUtilParseConversationId({
    required String conversationId,
  });

  Future<FfiGetEmoticonResponse> crateApiEmotionApiRefreshEmoticonList();

  Future<FfiUser> crateApiUserApiRefreshUser({required PlatformInt64 uid});

  Future<FfiRegResponse> crateApiLoginApiRegister({
    required String countryCode,
    required String account,
    required AccountType accountType,
    required String smsCode,
  });

  Future<FfiMessageModel> crateApiChatApiSendMessage({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required FfiMsgContent msgContent,
    FfiReferenceObj? refObj,
  });

  Future<FfiMessageModel> crateApiChatApiSendMessageWithJson({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required FfiMsgType msgType,
    required String contentObj,
  });

  Stream<Rust2ClientMessagePayload> crateApiChatApiSetClientMessageStream();

  Future<void> crateApiChatApiSetConversationArchive({
    required String conversationId,
    required int isArchive,
  });

  Future<void> crateApiChatApiSetConversationTop({
    required String conversationId,
    required bool isTop,
  });

  Future<void> crateApiAppApiSetLoggerLevel({required String level});

  Future<void> crateApiAppApiSetPushNotificationType({
    required FfiPushNotificationType pushType,
    FfiChatType? chatType,
    PlatformInt64? targetId,
  });

  Future<bool> crateApiEmotionApiShouldAutoRefresh();

  Future<void> crateApiAppApiStartTcpClientConnection();

  Future<void> crateApiAppApiStopTcpClient();

  Future<bool> crateApiContactsApiUpdateContactDisturb({
    required PlatformInt64 contactsId,
    required bool bfDisturb,
  });

  Future<bool> crateApiContactsApiUpdateContactRemark({
    required PlatformInt64 contactsId,
    required String noteName,
  });

  Future<bool> crateApiContactsApiUpdateContactStar({
    required PlatformInt64 contactsId,
    required bool bfStar,
  });

  Future<bool> crateApiContactsApiUpdateContactTop({
    required PlatformInt64 contactsId,
    required bool bfTop,
  });

  Future<bool> crateApiContactsApiUpdateContactsData({
    required PlatformInt64 contactsId,
    required bool bfDisturb,
  });

  Future<void> crateApiAppApiUpdateTcpClientConfig({
    String? serverAddr,
    int? serverPort,
    PlatformInt64? uid,
  });

  Future<void> crateApiUserApiUpdateUser({required FfiUser ffiUser});

  Future<void> crateApiAppApiUpdateUserConfig({
    required PlatformInt64 uid,
    required String sessionId,
    FfiUrlInfo? urls,
  });

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcFfiMessageContentTrait;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcFfiMessageContentTrait;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ArcFfiMessageContentTraitPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiChatApiBatchDeleteConversations({
    required List<(FfiChatType, PlatformInt64)> conversationIds,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_record_ffi_chat_type_i_64(
            conversationIds,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiBatchDeleteConversationsConstMeta,
        argValues: [conversationIds],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiBatchDeleteConversationsConstMeta =>
      const TaskConstMeta(
        debugName: "batch_delete_conversations",
        argNames: ["conversationIds"],
      );

  @override
  Future<void> crateApiChatApiBatchMarkConversationAsRead({
    required List<(FfiChatType, PlatformInt64)> conversationIds,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_record_ffi_chat_type_i_64(
            conversationIds,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 7,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiBatchMarkConversationAsReadConstMeta,
        argValues: [conversationIds],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiBatchMarkConversationAsReadConstMeta =>
      const TaskConstMeta(
        debugName: "batch_mark_conversation_as_read",
        argNames: ["conversationIds"],
      );

  @override
  Future<void> crateApiEmotionApiClearEmoticonCache() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiClearEmoticonCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiClearEmoticonCacheConstMeta =>
      const TaskConstMeta(debugName: "clear_emoticon_cache", argNames: []);

  @override
  Future<bool> crateApiContactsApiContactOperation({
    required ContactsOperator operation,
    required ContactsParam params,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_contacts_operator(operation, serializer);
          sse_encode_box_autoadd_contacts_param(params, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiContactOperationConstMeta,
        argValues: [operation, params],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiContactOperationConstMeta =>
      const TaskConstMeta(
        debugName: "contact_operation",
        argNames: ["operation", "params"],
      );

  @override
  Future<String> crateApiDownloadApiDecompressZipFile({
    required String inputPath,
    String? outputPath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(inputPath, serializer);
          sse_encode_opt_String(outputPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadApiDecompressZipFileConstMeta,
        argValues: [inputPath, outputPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDecompressZipFileConstMeta =>
      const TaskConstMeta(
        debugName: "decompress_zip_file",
        argNames: ["inputPath", "outputPath"],
      );

  @override
  Future<String> crateApiDownloadApiDecompressZlibFile({
    required String inputPath,
    String? outputPath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(inputPath, serializer);
          sse_encode_opt_String(outputPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadApiDecompressZlibFileConstMeta,
        argValues: [inputPath, outputPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDecompressZlibFileConstMeta =>
      const TaskConstMeta(
        debugName: "decompress_zlib_file",
        argNames: ["inputPath", "outputPath"],
      );

  @override
  Future<void> crateApiChatApiDeleteConversation({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiDeleteConversationConstMeta,
        argValues: [chatType, targetId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiDeleteConversationConstMeta =>
      const TaskConstMeta(
        debugName: "delete_conversation",
        argNames: ["chatType", "targetId"],
      );

  @override
  Future<DownloadResult> crateApiDownloadApiDownloadFileEncryptedApi({
    required String baseUrl,
    required String endpoint,
    required String savePath,
    required bool autoUnzip,
    Map<String, String>? customHeaders,
    bool? extractToFolder,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(baseUrl, serializer);
          sse_encode_String(endpoint, serializer);
          sse_encode_String(savePath, serializer);
          sse_encode_bool(autoUnzip, serializer);
          sse_encode_opt_Map_String_String_None(customHeaders, serializer);
          sse_encode_opt_box_autoadd_bool(extractToFolder, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 13,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_download_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiDownloadFileEncryptedApiConstMeta,
        argValues: [
          baseUrl,
          endpoint,
          savePath,
          autoUnzip,
          customHeaders,
          extractToFolder,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDownloadFileEncryptedApiConstMeta =>
      const TaskConstMeta(
        debugName: "download_file_encrypted_api",
        argNames: [
          "baseUrl",
          "endpoint",
          "savePath",
          "autoUnzip",
          "customHeaders",
          "extractToFolder",
        ],
      );

  @override
  Future<DownloadResult> crateApiDownloadApiDownloadFileHttp({
    required String url,
    required String savePath,
    required bool autoUnzip,
    Map<String, String>? customHeaders,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(url, serializer);
          sse_encode_String(savePath, serializer);
          sse_encode_bool(autoUnzip, serializer);
          sse_encode_opt_Map_String_String_None(customHeaders, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_download_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiDownloadFileHttpConstMeta,
        argValues: [url, savePath, autoUnzip, customHeaders],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDownloadFileHttpConstMeta =>
      const TaskConstMeta(
        debugName: "download_file_http",
        argNames: ["url", "savePath", "autoUnzip", "customHeaders"],
      );

  @override
  Future<DownloadResult> crateApiDownloadApiDownloadFileHttpEnhanced({
    required String url,
    required String savePath,
    required bool autoUnzip,
    Map<String, String>? customHeaders,
    required FileOverwritePolicy overwritePolicy,
    required bool calculateHash,
    bool? extractToFolder,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(url, serializer);
          sse_encode_String(savePath, serializer);
          sse_encode_bool(autoUnzip, serializer);
          sse_encode_opt_Map_String_String_None(customHeaders, serializer);
          sse_encode_file_overwrite_policy(overwritePolicy, serializer);
          sse_encode_bool(calculateHash, serializer);
          sse_encode_opt_box_autoadd_bool(extractToFolder, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 15,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_download_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiDownloadFileHttpEnhancedConstMeta,
        argValues: [
          url,
          savePath,
          autoUnzip,
          customHeaders,
          overwritePolicy,
          calculateHash,
          extractToFolder,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDownloadFileHttpEnhancedConstMeta =>
      const TaskConstMeta(
        debugName: "download_file_http_enhanced",
        argNames: [
          "url",
          "savePath",
          "autoUnzip",
          "customHeaders",
          "overwritePolicy",
          "calculateHash",
          "extractToFolder",
        ],
      );

  @override
  Future<List<DownloadResult>> crateApiDownloadApiDownloadFilesBatch({
    required List<DownloadTask> downloadTasks,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_download_task(downloadTasks, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_download_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiDownloadFilesBatchConstMeta,
        argValues: [downloadTasks],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDownloadFilesBatchConstMeta =>
      const TaskConstMeta(
        debugName: "download_files_batch",
        argNames: ["downloadTasks"],
      );

  @override
  Future<List<DownloadResult>> crateApiDownloadApiDownloadFilesBatchEnhanced({
    required List<DownloadTaskEnhanced> downloadTasks,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_download_task_enhanced(downloadTasks, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 17,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_download_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiDownloadFilesBatchEnhancedConstMeta,
        argValues: [downloadTasks],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiDownloadFilesBatchEnhancedConstMeta =>
      const TaskConstMeta(
        debugName: "download_files_batch_enhanced",
        argNames: ["downloadTasks"],
      );

  @override
  Future<DownloadProgressInfo> crateApiModelFfiDownloadDownloadProgressInfoNew({
    required PlatformInt64 downloadedBytes,
    PlatformInt64? totalBytes,
    required double progressPercentage,
    required String url,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(downloadedBytes, serializer);
          sse_encode_opt_box_autoadd_i_64(totalBytes, serializer);
          sse_encode_f_64(progressPercentage, serializer);
          sse_encode_String(url, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_download_progress_info,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiDownloadDownloadProgressInfoNewConstMeta,
        argValues: [downloadedBytes, totalBytes, progressPercentage, url],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiDownloadDownloadProgressInfoNewConstMeta =>
      const TaskConstMeta(
        debugName: "download_progress_info_new",
        argNames: [
          "downloadedBytes",
          "totalBytes",
          "progressPercentage",
          "url",
        ],
      );

  @override
  Future<FfiAnmatedMessageContent>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_anmated_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_anmated_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToJsonString({
    required FfiAnmatedMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_anmated_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_anmated_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToProtoData({
    required FfiAnmatedMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_anmated_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_anmated_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentGetFfiSubMsgType({
    required FfiAnmatedMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_anmated_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_anmated_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentJsonToFfi({
    required FfiAnmatedMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_anmated_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_anmated_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentGameFfiAnmatedMessageContentProtoDecodeToJson({
    required FfiAnmatedMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_anmated_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 24,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGameFfiAnmatedMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_anmated_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiAudioMessageContent>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 25,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_audio_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_audio_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToJsonString({
    required FfiAudioMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_audio_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 26,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_audio_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToProtoData({
    required FfiAudioMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_audio_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_audio_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentGetFfiSubMsgType({
    required FfiAudioMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_audio_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 28,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_audio_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentJsonToFfi({
    required FfiAudioMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_audio_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_audio_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentAudioFfiAudioMessageContentProtoDecodeToJson({
    required FfiAudioMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_audio_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentAudioFfiAudioMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_audio_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiChatTransferMessageContent>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_chat_transfer_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_transfer_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToJsonString({
    required FfiChatTransferMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_chat_transfer_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_transfer_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToProtoData({
    required FfiChatTransferMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_chat_transfer_message_content(
            that,
            serializer,
          );
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_transfer_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentGetFfiSubMsgType({
    required FfiChatTransferMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_chat_transfer_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_transfer_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentJsonToFfi({
    required FfiChatTransferMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_chat_transfer_message_content(
            that,
            serializer,
          );
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 35,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_transfer_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentTransferFfiChatTransferMessageContentProtoDecodeToJson({
    required FfiChatTransferMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_chat_transfer_message_content(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 36,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTransferFfiChatTransferMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_transfer_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiChatType> crateApiModelFfiMessageCommonFfiChatTypeFromI32({
    required int value,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(value, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 37,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_chat_type,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageCommonFfiChatTypeFromI32ConstMeta,
        argValues: [value],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageCommonFfiChatTypeFromI32ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_type_from_i32",
        argNames: ["value"],
      );

  @override
  Future<int> crateApiModelFfiMessageCommonFfiChatTypeToI32({
    required FfiChatType that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageCommonFfiChatTypeToI32ConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageCommonFfiChatTypeToI32ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_chat_type_to_i32",
        argNames: ["that"],
      );

  @override
  Future<FfiCommonMessageModel>
  crateApiModelFfiMessageCommonFfiCommonMessageModelNew({
    required PlatformInt64 targetId,
    required FfiChatType chatType,
    required FfiMsgType msgType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(targetId, serializer);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_ffi_msg_type(msgType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_common_message_model,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageCommonFfiCommonMessageModelNewConstMeta,
        argValues: [targetId, chatType, msgType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageCommonFfiCommonMessageModelNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_common_message_model_new",
        argNames: ["targetId", "chatType", "msgType"],
      );

  @override
  Future<FfiContactDetail> crateApiModelContactsFfiContactDetailFrom({
    required ContactsDetailBase detail,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_contacts_detail_base(detail, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_contact_detail,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelContactsFfiContactDetailFromConstMeta,
        argValues: [detail],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelContactsFfiContactDetailFromConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_contact_detail_from",
        argNames: ["detail"],
      );

  @override
  Future<FfiDiceMessageContent>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_dice_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dice_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToJsonString({
    required FfiDiceMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dice_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 42,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dice_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToProtoData({
    required FfiDiceMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dice_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dice_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentGetFfiSubMsgType({
    required FfiDiceMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dice_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dice_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentJsonToFfi({
    required FfiDiceMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dice_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dice_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentDiceFfiDiceMessageContentProtoDecodeToJson({
    required FfiDiceMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dice_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 46,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDiceFfiDiceMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dice_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiDynamicImageMessageContent>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 47,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_dynamic_image_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dynamic_image_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToJsonString({
    required FfiDynamicImageMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dynamic_image_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 48,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dynamic_image_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToProtoData({
    required FfiDynamicImageMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dynamic_image_message_content(
            that,
            serializer,
          );
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 49,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dynamic_image_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentGetFfiSubMsgType({
    required FfiDynamicImageMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dynamic_image_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 50,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dynamic_image_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentJsonToFfi({
    required FfiDynamicImageMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dynamic_image_message_content(
            that,
            serializer,
          );
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 51,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dynamic_image_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentProtoDecodeToJson({
    required FfiDynamicImageMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_dynamic_image_message_content(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 52,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentDynamicImageFfiDynamicImageMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_dynamic_image_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiFileMessageContent>
  crateApiModelFfiMessageContentFileFfiFileMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 53,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_file_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFileFfiFileMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFileFfiFileMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_file_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentFileFfiFileMessageContentFfiToJsonString({
    required FfiFileMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_file_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 54,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFileFfiFileMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFileFfiFileMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_file_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentFileFfiFileMessageContentFfiToProtoData({
    required FfiFileMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_file_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 55,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFileFfiFileMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFileFfiFileMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_file_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentFileFfiFileMessageContentGetFfiSubMsgType({
    required FfiFileMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_file_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 56,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFileFfiFileMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFileFfiFileMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_file_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentFileFfiFileMessageContentJsonToFfi({
    required FfiFileMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_file_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 57,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFileFfiFileMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFileFfiFileMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_file_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentFileFfiFileMessageContentProtoDecodeToJson({
    required FfiFileMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_file_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 58,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFileFfiFileMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFileFfiFileMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_file_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiGroupEventMessageContent>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 59,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_group_event_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToJsonString({
    required FfiGroupEventMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_group_event_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 60,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToProtoData({
    required FfiGroupEventMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_group_event_message_content(
            that,
            serializer,
          );
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 61,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentGetFfiSubMsgType({
    required FfiGroupEventMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_group_event_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 62,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentJsonToFfi({
    required FfiGroupEventMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_group_event_message_content(
            that,
            serializer,
          );
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 63,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<FfiGroupEventMessageContent>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentNew({
    required int rawMsgType,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(rawMsgType, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 64,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_group_event_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentNewConstMeta,
        argValues: [rawMsgType, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_new",
        argNames: ["rawMsgType", "content"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentProtoDecodeToJson({
    required FfiGroupEventMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_group_event_message_content(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 65,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentGroupEventFfiGroupEventMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_group_event_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiHtml2MessageContent>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 66,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_html_2_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_2_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToJsonString({
    required FfiHtml2MessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_2_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 67,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_2_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToProtoData({
    required FfiHtml2MessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_2_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 68,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_2_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentGetFfiSubMsgType({
    required FfiHtml2MessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_2_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 69,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_2_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentJsonToFfi({
    required FfiHtml2MessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_2_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 70,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_2_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentHtml2FfiHtml2MessageContentProtoDecodeToJson({
    required FfiHtml2MessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_2_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 71,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtml2FfiHtml2MessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_2_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiHtmlMessageContent>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 72,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_html_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToJsonString({
    required FfiHtmlMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 73,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToProtoData({
    required FfiHtmlMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 74,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentGetFfiSubMsgType({
    required FfiHtmlMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 75,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentJsonToFfi({
    required FfiHtmlMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 76,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentHtmlFfiHtmlMessageContentProtoDecodeToJson({
    required FfiHtmlMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_html_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 77,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentHtmlFfiHtmlMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_html_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiImageMessageContent>
  crateApiModelFfiMessageContentImageFfiImageMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 78,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_image_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentImageFfiImageMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentImageFfiImageMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_image_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentImageFfiImageMessageContentFfiToJsonString({
    required FfiImageMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_image_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 79,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentImageFfiImageMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentImageFfiImageMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_image_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentImageFfiImageMessageContentFfiToProtoData({
    required FfiImageMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_image_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 80,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentImageFfiImageMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentImageFfiImageMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_image_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentImageFfiImageMessageContentGetFfiSubMsgType({
    required FfiImageMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_image_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 81,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentImageFfiImageMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentImageFfiImageMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_image_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentImageFfiImageMessageContentJsonToFfi({
    required FfiImageMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_image_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 82,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentImageFfiImageMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentImageFfiImageMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_image_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentImageFfiImageMessageContentProtoDecodeToJson({
    required FfiImageMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_image_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 83,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentImageFfiImageMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentImageFfiImageMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_image_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiInitParams> crateApiModelFfiInitParamsFfiInitParamsDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 84,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_init_params,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiInitParamsFfiInitParamsDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiInitParamsFfiInitParamsDefaultConstMeta =>
      const TaskConstMeta(debugName: "ffi_init_params_default", argNames: []);

  @override
  Future<FfiLocationMessageContent>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 85,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_location_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_location_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToJsonString({
    required FfiLocationMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_location_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 86,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_location_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToProtoData({
    required FfiLocationMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_location_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 87,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_location_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentGetFfiSubMsgType({
    required FfiLocationMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_location_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 88,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_location_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentJsonToFfi({
    required FfiLocationMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_location_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 89,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_location_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentLocationFfiLocationMessageContentProtoDecodeToJson({
    required FfiLocationMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_location_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 90,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentLocationFfiLocationMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_location_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiMediasCaptionMessageContent>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 91,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_medias_caption_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_medias_caption_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToJsonString({
    required FfiMediasCaptionMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_medias_caption_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 92,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_medias_caption_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToProtoData({
    required FfiMediasCaptionMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_medias_caption_message_content(
            that,
            serializer,
          );
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 93,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_medias_caption_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentGetFfiSubMsgType({
    required FfiMediasCaptionMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_medias_caption_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 94,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_medias_caption_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentJsonToFfi({
    required FfiMediasCaptionMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_medias_caption_message_content(
            that,
            serializer,
          );
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 95,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_medias_caption_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentProtoDecodeToJson({
    required FfiMediasCaptionMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_medias_caption_message_content(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 96,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentMediasCaptionFfiMediasCaptionMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_medias_caption_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiMessageModel>
  crateApiModelFfiMessageModelFfiMessageModelCreateSendMessage({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required PlatformInt64 sendTime,
    FfiReferenceObj? refObj,
    required ArcFfiMessageContentTrait ffiContent,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          sse_encode_i_64(sendTime, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(refObj, serializer);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
            ffiContent,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 97,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_message_model,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageModelFfiMessageModelCreateSendMessageConstMeta,
        argValues: [chatType, targetId, sendTime, refObj, ffiContent],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageModelFfiMessageModelCreateSendMessageConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_message_model_create_send_message",
        argNames: ["chatType", "targetId", "sendTime", "refObj", "ffiContent"],
      );

  @override
  Future<FfiMessageModel>
  crateApiModelFfiMessageModelFfiMessageModelFfiMessageFromProto({
    required FfiMessageMetaData metaData,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_message_meta_data(metaData, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 98,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_message_model,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageModelFfiMessageModelFfiMessageFromProtoConstMeta,
        argValues: [metaData],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageModelFfiMessageModelFfiMessageFromProtoConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_message_model_ffi_message_from_proto",
        argNames: ["metaData"],
      );

  @override
  Future<PlatformInt64> crateApiModelFfiMessageModelFfiMessageModelGetTargetId({
    required FfiMessageModel that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_message_model(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 99,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_64,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageModelFfiMessageModelGetTargetIdConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageModelFfiMessageModelGetTargetIdConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_message_model_get_target_id",
        argNames: ["that"],
      );

  @override
  Future<FfiMessageUser>
  crateApiModelFfiMessageUserFfiMessageUserCurrentSender() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 100,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_message_user,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageUserFfiMessageUserCurrentSenderConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageUserFfiMessageUserCurrentSenderConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_message_user_current_sender",
        argNames: [],
      );

  @override
  Future<ArcFfiMessageContentTrait>
  crateApiModelFfiMessageContentFfiMsgContentGetContent({
    required FfiMsgContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_msg_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 101,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentFfiMsgContentGetContentConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentFfiMsgContentGetContentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_msg_content_get_content",
        argNames: ["that"],
      );

  @override
  Future<FfiMsgType> crateApiModelFfiMessageCommonFfiMsgTypeDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 102,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageCommonFfiMsgTypeDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageCommonFfiMsgTypeDefaultConstMeta =>
      const TaskConstMeta(debugName: "ffi_msg_type_default", argNames: []);

  @override
  Future<FfiMsgType> crateApiModelFfiMessageCommonFfiMsgTypeFromI32({
    required int value,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(value, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 103,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageCommonFfiMsgTypeFromI32ConstMeta,
        argValues: [value],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageCommonFfiMsgTypeFromI32ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_msg_type_from_i32",
        argNames: ["value"],
      );

  @override
  Future<int> crateApiModelFfiMessageCommonFfiMsgTypeToI32({
    required FfiMsgType that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_msg_type(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 104,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageCommonFfiMsgTypeToI32ConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageCommonFfiMsgTypeToI32ConstMeta =>
      const TaskConstMeta(debugName: "ffi_msg_type_to_i32", argNames: ["that"]);

  @override
  Future<FfiNameCardMessageContent>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 105,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_name_card_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_name_card_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToJsonString({
    required FfiNameCardMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_name_card_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 106,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_name_card_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToProtoData({
    required FfiNameCardMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_name_card_message_content(
            that,
            serializer,
          );
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 107,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_name_card_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentGetFfiSubMsgType({
    required FfiNameCardMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_name_card_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 108,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_name_card_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentJsonToFfi({
    required FfiNameCardMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_name_card_message_content(
            that,
            serializer,
          );
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 109,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_name_card_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentNameCardFfiNameCardMessageContentProtoDecodeToJson({
    required FfiNameCardMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_name_card_message_content(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 110,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNameCardFfiNameCardMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_name_card_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiNoticeMessageContent>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 111,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_notice_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_notice_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToJsonString({
    required FfiNoticeMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_notice_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 112,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_notice_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToProtoData({
    required FfiNoticeMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_notice_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 113,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_notice_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentGetFfiSubMsgType({
    required FfiNoticeMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_notice_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 114,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_notice_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentJsonToFfi({
    required FfiNoticeMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_notice_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 115,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_notice_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentNoticeFfiNoticeMessageContentProtoDecodeToJson({
    required FfiNoticeMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_notice_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 116,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentNoticeFfiNoticeMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_notice_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiPushNotificationType>
  crateApiModelChatFfiPushNotificationTypeDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 117,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_push_notification_type,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelChatFfiPushNotificationTypeDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelChatFfiPushNotificationTypeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_push_notification_type_default",
        argNames: [],
      );

  @override
  Future<FfiRedPacketMessageContent>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 118,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_red_packet_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_red_packet_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToJsonString({
    required FfiRedPacketMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_red_packet_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 119,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_red_packet_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToProtoData({
    required FfiRedPacketMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_red_packet_message_content(
            that,
            serializer,
          );
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 120,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_red_packet_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentGetFfiSubMsgType({
    required FfiRedPacketMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_red_packet_message_content(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 121,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_red_packet_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentJsonToFfi({
    required FfiRedPacketMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_red_packet_message_content(
            that,
            serializer,
          );
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 122,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_red_packet_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentProtoDecodeToJson({
    required FfiRedPacketMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_red_packet_message_content(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 123,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_red_packet_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiReferenceObj>
  crateApiModelFfiMessageCommonFfiReferenceObjDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 124,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_reference_obj,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageCommonFfiReferenceObjDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageCommonFfiReferenceObjDefaultConstMeta =>
      const TaskConstMeta(debugName: "ffi_reference_obj_default", argNames: []);

  @override
  Future<FfiSystemMessageContent>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 125,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_system_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_system_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToJsonString({
    required FfiSystemMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_system_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 126,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_system_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToProtoData({
    required FfiSystemMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_system_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 127,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_system_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentGetFfiSubMsgType({
    required FfiSystemMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_system_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 128,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_system_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentJsonToFfi({
    required FfiSystemMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_system_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 129,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_system_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentSystemFfiSystemMessageContentProtoDecodeToJson({
    required FfiSystemMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_system_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 130,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentSystemFfiSystemMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_system_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiTextMessageContent>
  crateApiModelFfiMessageContentTextFfiTextMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 131,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_text_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTextFfiTextMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTextFfiTextMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_text_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentTextFfiTextMessageContentFfiToJsonString({
    required FfiTextMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_text_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 132,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTextFfiTextMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTextFfiTextMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_text_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentTextFfiTextMessageContentFfiToProtoData({
    required FfiTextMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_text_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 133,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTextFfiTextMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTextFfiTextMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_text_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentTextFfiTextMessageContentGetFfiSubMsgType({
    required FfiTextMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_text_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 134,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTextFfiTextMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTextFfiTextMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_text_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentTextFfiTextMessageContentJsonToFfi({
    required FfiTextMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_text_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 135,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTextFfiTextMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTextFfiTextMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_text_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentTextFfiTextMessageContentProtoDecodeToJson({
    required FfiTextMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_text_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 136,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentTextFfiTextMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentTextFfiTextMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_text_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiUnknownMessageContent>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 137,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_unknown_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToJsonString({
    required FfiUnknownMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_unknown_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 138,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToProtoData({
    required FfiUnknownMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_unknown_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 139,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentGetFfiSubMsgType({
    required FfiUnknownMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_unknown_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 140,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentJsonToFfi({
    required FfiUnknownMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_unknown_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 141,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<FfiUnknownMessageContent>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentNew({
    required int rawMsgType,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(rawMsgType, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 142,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_unknown_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentNewConstMeta,
        argValues: [rawMsgType, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_new",
        argNames: ["rawMsgType", "content"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentUnknownFfiUnknownMessageContentProtoDecodeToJson({
    required FfiUnknownMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_unknown_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 143,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentUnknownFfiUnknownMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unknown_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<FfiVideoMessageContent>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 144,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_video_message_content,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_video_message_content_default",
        argNames: [],
      );

  @override
  Future<String>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToJsonString({
    required FfiVideoMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_video_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 145,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToJsonStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToJsonStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_video_message_content_ffi_to_json_string",
        argNames: ["that"],
      );

  @override
  Future<Uint8List>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToProtoData({
    required FfiVideoMessageContent that,
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_video_message_content(that, serializer);
          sse_encode_String(contentObj, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(ffiRefObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 146,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToProtoDataConstMeta,
        argValues: [that, contentObj, ffiRefObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentFfiToProtoDataConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_video_message_content_ffi_to_proto_data",
        argNames: ["that", "contentObj", "ffiRefObj"],
      );

  @override
  Future<FfiMsgType>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentGetFfiSubMsgType({
    required FfiVideoMessageContent that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_video_message_content(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 147,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_msg_type,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentGetFfiSubMsgTypeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentGetFfiSubMsgTypeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_video_message_content_get_ffi_sub_msg_type",
        argNames: ["that"],
      );

  @override
  Future<void>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentJsonToFfi({
    required FfiVideoMessageContent that,
    required String uniKey,
    required String jsonStr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_video_message_content(that, serializer);
          sse_encode_String(uniKey, serializer);
          sse_encode_String(jsonStr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 148,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentJsonToFfiConstMeta,
        argValues: [that, uniKey, jsonStr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentJsonToFfiConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_video_message_content_json_to_ffi",
        argNames: ["that", "uniKey", "jsonStr"],
      );

  @override
  Future<(String, FfiReferenceObj?)>
  crateApiModelFfiMessageContentVideoFfiVideoMessageContentProtoDecodeToJson({
    required FfiVideoMessageContent that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_video_message_content(that, serializer);
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 149,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_record_string_opt_box_autoadd_ffi_reference_obj,
          decodeErrorData: sse_decode_message_error,
        ),
        constMeta:
            kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentProtoDecodeToJsonConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiModelFfiMessageContentVideoFfiVideoMessageContentProtoDecodeToJsonConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_video_message_content_proto_decode_to_json",
        argNames: ["that", "content"],
      );

  @override
  Future<ArcFfiMessageContentTrait>
  crateApiModelFfiMessageContentFindProcesser({required int msgTypeVal}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(msgTypeVal, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 150,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageContentFindProcesserConstMeta,
        argValues: [msgTypeVal],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageContentFindProcesserConstMeta =>
      const TaskConstMeta(
        debugName: "find_processer",
        argNames: ["msgTypeVal"],
      );

  @override
  Future<FfiEmoticonListResult> crateApiEmotionApiForceUpdateEmoticonList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 151,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_emoticon_list_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiForceUpdateEmoticonListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiForceUpdateEmoticonListConstMeta =>
      const TaskConstMeta(
        debugName: "force_update_emoticon_list",
        argNames: [],
      );

  @override
  Future<String> crateApiConversationIdUtilGenarateConversationId({
    required int chatTypeVal,
    required PlatformInt64 targetId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(chatTypeVal, serializer);
          sse_encode_i_64(targetId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 152,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConversationIdUtilGenarateConversationIdConstMeta,
        argValues: [chatTypeVal, targetId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiConversationIdUtilGenarateConversationIdConstMeta =>
      const TaskConstMeta(
        debugName: "genarate_conversation_id",
        argNames: ["chatTypeVal", "targetId"],
      );

  @override
  Future<List<FfiConversation>> crateApiChatApiGetArchivedConversations() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 153,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_conversation,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiGetArchivedConversationsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiGetArchivedConversationsConstMeta =>
      const TaskConstMeta(
        debugName: "get_archived_conversations",
        argNames: [],
      );

  @override
  Future<FfiConversation?> crateApiChatApiGetArchivedGroup() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 154,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_ffi_conversation,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiGetArchivedGroupConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiGetArchivedGroupConstMeta =>
      const TaskConstMeta(debugName: "get_archived_group", argNames: []);

  @override
  Future<String> crateApiEmotionApiGetCacheInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 155,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiGetCacheInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiGetCacheInfoConstMeta =>
      const TaskConstMeta(debugName: "get_cache_info", argNames: []);

  @override
  Future<List<FfiChannelModel>> crateApiChannelApiGetChannelContactList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 156,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_channel_model,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChannelApiGetChannelContactListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChannelApiGetChannelContactListConstMeta =>
      const TaskConstMeta(debugName: "get_channel_contact_list", argNames: []);

  @override
  Future<FfiChannelModel?> crateApiChannelApiGetChannelDetail({
    required PlatformInt64 channelId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(channelId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 157,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_ffi_channel_model,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChannelApiGetChannelDetailConstMeta,
        argValues: [channelId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChannelApiGetChannelDetailConstMeta =>
      const TaskConstMeta(
        debugName: "get_channel_detail",
        argNames: ["channelId"],
      );

  @override
  Future<int> crateApiChannelApiGetChannelMemberCount({
    required String conversationId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 158,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChannelApiGetChannelMemberCountConstMeta,
        argValues: [conversationId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChannelApiGetChannelMemberCountConstMeta =>
      const TaskConstMeta(
        debugName: "get_channel_member_count",
        argNames: ["conversationId"],
      );

  @override
  Future<List<FfiConversation>> crateApiChatApiGetChatConversations() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 159,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_conversation,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiGetChatConversationsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiGetChatConversationsConstMeta =>
      const TaskConstMeta(debugName: "get_chat_conversations", argNames: []);

  @override
  Future<List<FfiMessageModel>> crateApiChatApiGetChatHistory({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required int limit,
    PlatformInt64? beforeId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          sse_encode_i_32(limit, serializer);
          sse_encode_opt_box_autoadd_i_64(beforeId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 160,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_message_model,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiGetChatHistoryConstMeta,
        argValues: [chatType, targetId, limit, beforeId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiGetChatHistoryConstMeta =>
      const TaskConstMeta(
        debugName: "get_chat_history",
        argNames: ["chatType", "targetId", "limit", "beforeId"],
      );

  @override
  Future<List<FfiContactDetail>> crateApiContactsApiGetContactsList({
    required bool includePresences,
    required ContactOrderType orderType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(includePresences, serializer);
          sse_encode_contact_order_type(orderType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 161,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_contact_detail,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiGetContactsListConstMeta,
        argValues: [includePresences, orderType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiGetContactsListConstMeta =>
      const TaskConstMeta(
        debugName: "get_contacts_list",
        argNames: ["includePresences", "orderType"],
      );

  @override
  Future<String> crateApiConversationIdUtilGetConversationId({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 162,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConversationIdUtilGetConversationIdConstMeta,
        argValues: [chatType, targetId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConversationIdUtilGetConversationIdConstMeta =>
      const TaskConstMeta(
        debugName: "get_conversation_id",
        argNames: ["chatType", "targetId"],
      );

  @override
  Future<List<FfiConversation>> crateApiChatApiGetConversationsWithArchived() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 163,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_conversation,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiGetConversationsWithArchivedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiGetConversationsWithArchivedConstMeta =>
      const TaskConstMeta(
        debugName: "get_conversations_with_archived",
        argNames: [],
      );

  @override
  Future<String?> crateApiDownloadApiGetDocumentsDirectoryPath() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 164,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiGetDocumentsDirectoryPathConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiGetDocumentsDirectoryPathConstMeta =>
      const TaskConstMeta(
        debugName: "get_documents_directory_path",
        argNames: [],
      );

  @override
  Future<FfiGetEmoticonResponse> crateApiEmotionApiGetEmoticonList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 165,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_get_emoticon_response,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiGetEmoticonListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiGetEmoticonListConstMeta =>
      const TaskConstMeta(debugName: "get_emoticon_list", argNames: []);

  @override
  Future<FfiEmoticonListResult> crateApiEmotionApiGetEmoticonListAuto() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 166,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_emoticon_list_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiGetEmoticonListAutoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiGetEmoticonListAutoConstMeta =>
      const TaskConstMeta(debugName: "get_emoticon_list_auto", argNames: []);

  @override
  Future<List<FfiAnimatedGameConfig>> crateApiEmotionApiGetGameGlobalConfig() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 167,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_animated_game_config,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiGetGameGlobalConfigConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiGetGameGlobalConfigConstMeta =>
      const TaskConstMeta(debugName: "get_game_global_config", argNames: []);

  @override
  Future<List<FfiGroupBase>> crateApiGroupApiGetGroupContactList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 168,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_ffi_group_base,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGroupApiGetGroupContactListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGroupApiGetGroupContactListConstMeta =>
      const TaskConstMeta(debugName: "get_group_contact_list", argNames: []);

  @override
  Future<FfiGroupDetailResponse> crateApiGroupApiGetGroupDetail({
    required PlatformInt64 groupId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(groupId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 169,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_group_detail_response,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGroupApiGetGroupDetailConstMeta,
        argValues: [groupId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGroupApiGetGroupDetailConstMeta =>
      const TaskConstMeta(debugName: "get_group_detail", argNames: ["groupId"]);

  @override
  Future<int> crateApiGroupApiGetGroupMemberCount({
    required String conversationId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 170,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGroupApiGetGroupMemberCountConstMeta,
        argValues: [conversationId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGroupApiGetGroupMemberCountConstMeta =>
      const TaskConstMeta(
        debugName: "get_group_member_count",
        argNames: ["conversationId"],
      );

  @override
  Future<BigInt> crateApiEmotionApiGetLastUpdateTime() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 171,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiGetLastUpdateTimeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiGetLastUpdateTimeConstMeta =>
      const TaskConstMeta(debugName: "get_last_update_time", argNames: []);

  @override
  Future<void> crateApiLoginApiGetSmsCode({
    required String countryCode,
    required String phone,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(countryCode, serializer);
          sse_encode_String(phone, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 172,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLoginApiGetSmsCodeConstMeta,
        argValues: [countryCode, phone],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLoginApiGetSmsCodeConstMeta => const TaskConstMeta(
    debugName: "get_sms_code",
    argNames: ["countryCode", "phone"],
  );

  @override
  Future<PlatformInt64>
  crateApiConversationIdUtilGetTargetIdFromConversationId({
    required String conversationId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 173,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_64,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiConversationIdUtilGetTargetIdFromConversationIdConstMeta,
        argValues: [conversationId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiConversationIdUtilGetTargetIdFromConversationIdConstMeta =>
      const TaskConstMeta(
        debugName: "get_target_id_from_conversation_id",
        argNames: ["conversationId"],
      );

  @override
  Future<FfiUser> crateApiUserApiGetUser({required PlatformInt64 uid}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(uid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 174,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_user,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserApiGetUserConstMeta,
        argValues: [uid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserApiGetUserConstMeta =>
      const TaskConstMeta(debugName: "get_user", argNames: ["uid"]);

  @override
  Future<bool> crateApiAppApiInitApp({
    required FfiClientInfo clientInfo,
    required FfiInitParams initParams,
    required PlatformInt64 uid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_client_info(clientInfo, serializer);
          sse_encode_box_autoadd_ffi_init_params(initParams, serializer);
          sse_encode_i_64(uid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 175,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAppApiInitAppConstMeta,
        argValues: [clientInfo, initParams, uid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiInitAppConstMeta => const TaskConstMeta(
    debugName: "init_app",
    argNames: ["clientInfo", "initParams", "uid"],
  );

  @override
  Stream<String> crateApiAppApiInitLogger() {
    final stream = RustStreamSink<String>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_String_Sse(stream, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 176,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiAppApiInitLoggerConstMeta,
          argValues: [stream],
          apiImpl: this,
        ),
      ),
    );
    return stream.stream;
  }

  TaskConstMeta get kCrateApiAppApiInitLoggerConstMeta =>
      const TaskConstMeta(debugName: "init_logger", argNames: ["stream"]);

  @override
  Future<void> crateApiAppApiInitTableData() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 177,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAppApiInitTableDataConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiInitTableDataConstMeta =>
      const TaskConstMeta(debugName: "init_table_data", argNames: []);

  @override
  Future<bool> crateApiDownloadApiIsZipFile({required String filePath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(filePath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 178,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadApiIsZipFileConstMeta,
        argValues: [filePath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiIsZipFileConstMeta =>
      const TaskConstMeta(debugName: "is_zip_file", argNames: ["filePath"]);

  @override
  Future<bool> crateApiDownloadApiIsZlibFile({required String filePath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(filePath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 179,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadApiIsZlibFileConstMeta,
        argValues: [filePath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiIsZlibFileConstMeta =>
      const TaskConstMeta(debugName: "is_zlib_file", argNames: ["filePath"]);

  @override
  Stream<String> crateApiDownloadApiListenForDownloadProgress() {
    final sink = RustStreamSink<String>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_String_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 180,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiDownloadApiListenForDownloadProgressConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiDownloadApiListenForDownloadProgressConstMeta =>
      const TaskConstMeta(
        debugName: "listen_for_download_progress",
        argNames: ["sink"],
      );

  @override
  Stream<Rust2ClientMessagePayload> crateApiChatApiListenForMessages() {
    final sink = RustStreamSink<Rust2ClientMessagePayload>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_rust_2_client_message_payload_Sse(
              sink,
              serializer,
            );
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 181,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiChatApiListenForMessagesConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiChatApiListenForMessagesConstMeta =>
      const TaskConstMeta(debugName: "listen_for_messages", argNames: ["sink"]);

  @override
  Stream<FfiUser> crateApiUserApiListenForUserInfoUpdates() {
    final sink = RustStreamSink<FfiUser>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_ffi_user_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 182,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiUserApiListenForUserInfoUpdatesConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiUserApiListenForUserInfoUpdatesConstMeta =>
      const TaskConstMeta(
        debugName: "listen_for_user_info_updates",
        argNames: ["sink"],
      );

  @override
  Future<FfiLoginResponse> crateApiLoginApiLogin({
    required String countryCode,
    required String phone,
    required String smsCode,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(countryCode, serializer);
          sse_encode_String(phone, serializer);
          sse_encode_String(smsCode, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 183,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_login_response,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLoginApiLoginConstMeta,
        argValues: [countryCode, phone, smsCode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLoginApiLoginConstMeta => const TaskConstMeta(
    debugName: "login",
    argNames: ["countryCode", "phone", "smsCode"],
  );

  @override
  Future<FfiLoginResponse> crateApiLoginApiLoginByPassword({
    required String countryCode,
    required String phone,
    required String password,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(countryCode, serializer);
          sse_encode_String(phone, serializer);
          sse_encode_String(password, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 184,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_login_response,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLoginApiLoginByPasswordConstMeta,
        argValues: [countryCode, phone, password],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLoginApiLoginByPasswordConstMeta =>
      const TaskConstMeta(
        debugName: "login_by_password",
        argNames: ["countryCode", "phone", "password"],
      );

  @override
  Future<void> crateApiChatApiMarkConversationAsRead({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 185,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiMarkConversationAsReadConstMeta,
        argValues: [chatType, targetId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiMarkConversationAsReadConstMeta =>
      const TaskConstMeta(
        debugName: "mark_conversation_as_read",
        argNames: ["chatType", "targetId"],
      );

  @override
  Future<void> crateApiChatApiMarkMessageAsRead({required String msgId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(msgId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 186,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiMarkMessageAsReadConstMeta,
        argValues: [msgId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiMarkMessageAsReadConstMeta =>
      const TaskConstMeta(
        debugName: "mark_message_as_read",
        argNames: ["msgId"],
      );

  @override
  Future<void> crateApiChatApiMarkSessionAsRead({
    required String conversationId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 187,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiMarkSessionAsReadConstMeta,
        argValues: [conversationId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiMarkSessionAsReadConstMeta =>
      const TaskConstMeta(
        debugName: "mark_session_as_read",
        argNames: ["conversationId"],
      );

  @override
  Future<MessageError> crateApiModelFfiMessageContentMessageErrorNew({
    required String msg,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(msg, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 188,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_message_error,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelFfiMessageContentMessageErrorNewConstMeta,
        argValues: [msg],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelFfiMessageContentMessageErrorNewConstMeta =>
      const TaskConstMeta(debugName: "message_error_new", argNames: ["msg"]);

  @override
  Future<String> crateApiDownloadApiNormalizeFilePath({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 189,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloadApiNormalizeFilePathConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadApiNormalizeFilePathConstMeta =>
      const TaskConstMeta(debugName: "normalize_file_path", argNames: ["path"]);

  @override
  Future<bool> crateApiContactsApiNotifyContactAction({
    required PlatformInt64 userId,
    required String action,
    required String params,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(userId, serializer);
          sse_encode_String(action, serializer);
          sse_encode_String(params, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 190,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiNotifyContactActionConstMeta,
        argValues: [userId, action, params],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiNotifyContactActionConstMeta =>
      const TaskConstMeta(
        debugName: "notify_contact_action",
        argNames: ["userId", "action", "params"],
      );

  @override
  Future<(FfiChatType, PlatformInt64)>
  crateApiConversationIdUtilParseConversationId({
    required String conversationId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 191,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_record_ffi_chat_type_i_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConversationIdUtilParseConversationIdConstMeta,
        argValues: [conversationId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConversationIdUtilParseConversationIdConstMeta =>
      const TaskConstMeta(
        debugName: "parse_conversation_id",
        argNames: ["conversationId"],
      );

  @override
  Future<FfiGetEmoticonResponse> crateApiEmotionApiRefreshEmoticonList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 192,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_get_emoticon_response,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiRefreshEmoticonListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiRefreshEmoticonListConstMeta =>
      const TaskConstMeta(debugName: "refresh_emoticon_list", argNames: []);

  @override
  Future<FfiUser> crateApiUserApiRefreshUser({required PlatformInt64 uid}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(uid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 193,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_user,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserApiRefreshUserConstMeta,
        argValues: [uid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserApiRefreshUserConstMeta =>
      const TaskConstMeta(debugName: "refresh_user", argNames: ["uid"]);

  @override
  Future<FfiRegResponse> crateApiLoginApiRegister({
    required String countryCode,
    required String account,
    required AccountType accountType,
    required String smsCode,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(countryCode, serializer);
          sse_encode_String(account, serializer);
          sse_encode_account_type(accountType, serializer);
          sse_encode_String(smsCode, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 194,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_reg_response,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLoginApiRegisterConstMeta,
        argValues: [countryCode, account, accountType, smsCode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLoginApiRegisterConstMeta => const TaskConstMeta(
    debugName: "register",
    argNames: ["countryCode", "account", "accountType", "smsCode"],
  );

  @override
  Future<FfiMessageModel> crateApiChatApiSendMessage({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required FfiMsgContent msgContent,
    FfiReferenceObj? refObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          sse_encode_box_autoadd_ffi_msg_content(msgContent, serializer);
          sse_encode_opt_box_autoadd_ffi_reference_obj(refObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 195,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_message_model,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiSendMessageConstMeta,
        argValues: [chatType, targetId, msgContent, refObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiSendMessageConstMeta => const TaskConstMeta(
    debugName: "send_message",
    argNames: ["chatType", "targetId", "msgContent", "refObj"],
  );

  @override
  Future<FfiMessageModel> crateApiChatApiSendMessageWithJson({
    required FfiChatType chatType,
    required PlatformInt64 targetId,
    required FfiMsgType msgType,
    required String contentObj,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_chat_type(chatType, serializer);
          sse_encode_i_64(targetId, serializer);
          sse_encode_ffi_msg_type(msgType, serializer);
          sse_encode_String(contentObj, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 196,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_message_model,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiSendMessageWithJsonConstMeta,
        argValues: [chatType, targetId, msgType, contentObj],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiSendMessageWithJsonConstMeta =>
      const TaskConstMeta(
        debugName: "send_message_with_json",
        argNames: ["chatType", "targetId", "msgType", "contentObj"],
      );

  @override
  Stream<Rust2ClientMessagePayload> crateApiChatApiSetClientMessageStream() {
    final sink = RustStreamSink<Rust2ClientMessagePayload>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_rust_2_client_message_payload_Sse(
              sink,
              serializer,
            );
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 197,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiChatApiSetClientMessageStreamConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiChatApiSetClientMessageStreamConstMeta =>
      const TaskConstMeta(
        debugName: "set_client_message_stream",
        argNames: ["sink"],
      );

  @override
  Future<void> crateApiChatApiSetConversationArchive({
    required String conversationId,
    required int isArchive,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          sse_encode_i_32(isArchive, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 198,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiSetConversationArchiveConstMeta,
        argValues: [conversationId, isArchive],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiSetConversationArchiveConstMeta =>
      const TaskConstMeta(
        debugName: "set_conversation_archive",
        argNames: ["conversationId", "isArchive"],
      );

  @override
  Future<void> crateApiChatApiSetConversationTop({
    required String conversationId,
    required bool isTop,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(conversationId, serializer);
          sse_encode_bool(isTop, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 199,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatApiSetConversationTopConstMeta,
        argValues: [conversationId, isTop],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatApiSetConversationTopConstMeta =>
      const TaskConstMeta(
        debugName: "set_conversation_top",
        argNames: ["conversationId", "isTop"],
      );

  @override
  Future<void> crateApiAppApiSetLoggerLevel({required String level}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(level, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 200,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiAppApiSetLoggerLevelConstMeta,
        argValues: [level],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiSetLoggerLevelConstMeta =>
      const TaskConstMeta(debugName: "set_logger_level", argNames: ["level"]);

  @override
  Future<void> crateApiAppApiSetPushNotificationType({
    required FfiPushNotificationType pushType,
    FfiChatType? chatType,
    PlatformInt64? targetId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_ffi_push_notification_type(pushType, serializer);
          sse_encode_opt_box_autoadd_ffi_chat_type(chatType, serializer);
          sse_encode_opt_box_autoadd_i_64(targetId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 201,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiAppApiSetPushNotificationTypeConstMeta,
        argValues: [pushType, chatType, targetId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiSetPushNotificationTypeConstMeta =>
      const TaskConstMeta(
        debugName: "set_push_notification_type",
        argNames: ["pushType", "chatType", "targetId"],
      );

  @override
  Future<bool> crateApiEmotionApiShouldAutoRefresh() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 202,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEmotionApiShouldAutoRefreshConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEmotionApiShouldAutoRefreshConstMeta =>
      const TaskConstMeta(debugName: "should_auto_refresh", argNames: []);

  @override
  Future<void> crateApiAppApiStartTcpClientConnection() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 203,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAppApiStartTcpClientConnectionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiStartTcpClientConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "start_tcp_client_connection",
        argNames: [],
      );

  @override
  Future<void> crateApiAppApiStopTcpClient() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 204,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAppApiStopTcpClientConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiStopTcpClientConstMeta =>
      const TaskConstMeta(debugName: "stop_tcp_client", argNames: []);

  @override
  Future<bool> crateApiContactsApiUpdateContactDisturb({
    required PlatformInt64 contactsId,
    required bool bfDisturb,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(contactsId, serializer);
          sse_encode_bool(bfDisturb, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 205,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiUpdateContactDisturbConstMeta,
        argValues: [contactsId, bfDisturb],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiUpdateContactDisturbConstMeta =>
      const TaskConstMeta(
        debugName: "update_contact_disturb",
        argNames: ["contactsId", "bfDisturb"],
      );

  @override
  Future<bool> crateApiContactsApiUpdateContactRemark({
    required PlatformInt64 contactsId,
    required String noteName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(contactsId, serializer);
          sse_encode_String(noteName, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 206,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiUpdateContactRemarkConstMeta,
        argValues: [contactsId, noteName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiUpdateContactRemarkConstMeta =>
      const TaskConstMeta(
        debugName: "update_contact_remark",
        argNames: ["contactsId", "noteName"],
      );

  @override
  Future<bool> crateApiContactsApiUpdateContactStar({
    required PlatformInt64 contactsId,
    required bool bfStar,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(contactsId, serializer);
          sse_encode_bool(bfStar, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 207,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiUpdateContactStarConstMeta,
        argValues: [contactsId, bfStar],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiUpdateContactStarConstMeta =>
      const TaskConstMeta(
        debugName: "update_contact_star",
        argNames: ["contactsId", "bfStar"],
      );

  @override
  Future<bool> crateApiContactsApiUpdateContactTop({
    required PlatformInt64 contactsId,
    required bool bfTop,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(contactsId, serializer);
          sse_encode_bool(bfTop, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 208,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiUpdateContactTopConstMeta,
        argValues: [contactsId, bfTop],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiUpdateContactTopConstMeta =>
      const TaskConstMeta(
        debugName: "update_contact_top",
        argNames: ["contactsId", "bfTop"],
      );

  @override
  Future<bool> crateApiContactsApiUpdateContactsData({
    required PlatformInt64 contactsId,
    required bool bfDisturb,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(contactsId, serializer);
          sse_encode_bool(bfDisturb, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 209,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiContactsApiUpdateContactsDataConstMeta,
        argValues: [contactsId, bfDisturb],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiContactsApiUpdateContactsDataConstMeta =>
      const TaskConstMeta(
        debugName: "update_contacts_data",
        argNames: ["contactsId", "bfDisturb"],
      );

  @override
  Future<void> crateApiAppApiUpdateTcpClientConfig({
    String? serverAddr,
    int? serverPort,
    PlatformInt64? uid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_String(serverAddr, serializer);
          sse_encode_opt_box_autoadd_u_16(serverPort, serializer);
          sse_encode_opt_box_autoadd_i_64(uid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 210,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAppApiUpdateTcpClientConfigConstMeta,
        argValues: [serverAddr, serverPort, uid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiUpdateTcpClientConfigConstMeta =>
      const TaskConstMeta(
        debugName: "update_tcp_client_config",
        argNames: ["serverAddr", "serverPort", "uid"],
      );

  @override
  Future<void> crateApiUserApiUpdateUser({required FfiUser ffiUser}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_ffi_user(ffiUser, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 211,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserApiUpdateUserConstMeta,
        argValues: [ffiUser],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserApiUpdateUserConstMeta =>
      const TaskConstMeta(debugName: "update_user", argNames: ["ffiUser"]);

  @override
  Future<void> crateApiAppApiUpdateUserConfig({
    required PlatformInt64 uid,
    required String sessionId,
    FfiUrlInfo? urls,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(uid, serializer);
          sse_encode_String(sessionId, serializer);
          sse_encode_opt_box_autoadd_ffi_url_info(urls, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 212,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAppApiUpdateUserConfigConstMeta,
        argValues: [uid, sessionId, urls],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAppApiUpdateUserConfigConstMeta =>
      const TaskConstMeta(
        debugName: "update_user_config",
        argNames: ["uid", "sessionId", "urls"],
      );

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcFfiMessageContentTrait =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcFfiMessageContentTrait =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ArcFfiMessageContentTrait
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcFfiMessageContentTraitImpl.frbInternalDcoDecode(
      raw as List<dynamic>,
    );
  }

  @protected
  Map<String, String> dco_decode_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_string(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  ArcFfiMessageContentTrait
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcFfiMessageContentTraitImpl.frbInternalDcoDecode(
      raw as List<dynamic>,
    );
  }

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FfiUser> dco_decode_StreamSink_ffi_user_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<Rust2ClientMessagePayload>
  dco_decode_StreamSink_rust_2_client_message_payload_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  FfiMessageContentTrait dco_decode_TraitDef_FfiMessageContentTrait(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  AccountType dco_decode_account_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AccountType.values[raw as int];
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ContactsDetailBase dco_decode_box_autoadd_contacts_detail_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_contacts_detail_base(raw);
  }

  @protected
  ContactsParam dco_decode_box_autoadd_contacts_param(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_contacts_param(raw);
  }

  @protected
  FfiAnmatedMessageContent dco_decode_box_autoadd_ffi_anmated_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_anmated_message_content(raw);
  }

  @protected
  FfiAudioMessageContent dco_decode_box_autoadd_ffi_audio_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_audio_message_content(raw);
  }

  @protected
  FfiChannelModel dco_decode_box_autoadd_ffi_channel_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_channel_model(raw);
  }

  @protected
  FfiChatTransferMessageContent
  dco_decode_box_autoadd_ffi_chat_transfer_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_chat_transfer_message_content(raw);
  }

  @protected
  FfiChatType dco_decode_box_autoadd_ffi_chat_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_chat_type(raw);
  }

  @protected
  FfiClientInfo dco_decode_box_autoadd_ffi_client_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_client_info(raw);
  }

  @protected
  FfiConversation dco_decode_box_autoadd_ffi_conversation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_conversation(raw);
  }

  @protected
  FfiDiceMessageContent dco_decode_box_autoadd_ffi_dice_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_dice_message_content(raw);
  }

  @protected
  FfiDynamicImageMessageContent
  dco_decode_box_autoadd_ffi_dynamic_image_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_dynamic_image_message_content(raw);
  }

  @protected
  FfiFileMessageContent dco_decode_box_autoadd_ffi_file_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_file_message_content(raw);
  }

  @protected
  FfiGroupBase dco_decode_box_autoadd_ffi_group_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_group_base(raw);
  }

  @protected
  FfiGroupEventMessageContent
  dco_decode_box_autoadd_ffi_group_event_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_group_event_message_content(raw);
  }

  @protected
  FfiHtml2MessageContent dco_decode_box_autoadd_ffi_html_2_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_html_2_message_content(raw);
  }

  @protected
  FfiHtmlMessageContent dco_decode_box_autoadd_ffi_html_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_html_message_content(raw);
  }

  @protected
  FfiImageMessageContent dco_decode_box_autoadd_ffi_image_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_image_message_content(raw);
  }

  @protected
  FfiInitParams dco_decode_box_autoadd_ffi_init_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_init_params(raw);
  }

  @protected
  FfiLocationMessageContent dco_decode_box_autoadd_ffi_location_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_location_message_content(raw);
  }

  @protected
  FfiMediasCaptionMessageContent
  dco_decode_box_autoadd_ffi_medias_caption_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_medias_caption_message_content(raw);
  }

  @protected
  FfiMessageMetaData dco_decode_box_autoadd_ffi_message_meta_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_message_meta_data(raw);
  }

  @protected
  FfiMessageModel dco_decode_box_autoadd_ffi_message_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_message_model(raw);
  }

  @protected
  FfiMsgContent dco_decode_box_autoadd_ffi_msg_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_msg_content(raw);
  }

  @protected
  FfiNameCardMessageContent
  dco_decode_box_autoadd_ffi_name_card_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_name_card_message_content(raw);
  }

  @protected
  FfiNoticeMessageContent dco_decode_box_autoadd_ffi_notice_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_notice_message_content(raw);
  }

  @protected
  FfiRedPacketMessageContent
  dco_decode_box_autoadd_ffi_red_packet_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_red_packet_message_content(raw);
  }

  @protected
  FfiReferenceObj dco_decode_box_autoadd_ffi_reference_obj(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_reference_obj(raw);
  }

  @protected
  FfiSystemMessageContent dco_decode_box_autoadd_ffi_system_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_system_message_content(raw);
  }

  @protected
  FfiTextMessageContent dco_decode_box_autoadd_ffi_text_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_text_message_content(raw);
  }

  @protected
  FfiUnknownMessageContent dco_decode_box_autoadd_ffi_unknown_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_unknown_message_content(raw);
  }

  @protected
  FfiUrlInfo dco_decode_box_autoadd_ffi_url_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_url_info(raw);
  }

  @protected
  FfiUser dco_decode_box_autoadd_ffi_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_user(raw);
  }

  @protected
  FfiUserBase dco_decode_box_autoadd_ffi_user_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_user_base(raw);
  }

  @protected
  FfiVideoMessageContent dco_decode_box_autoadd_ffi_video_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_video_message_content(raw);
  }

  @protected
  FriendRelation dco_decode_box_autoadd_friend_relation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_friend_relation(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  UserBase dco_decode_box_autoadd_user_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_base(raw);
  }

  @protected
  UserOnOrOffLine dco_decode_box_autoadd_user_on_or_off_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_on_or_off_line(raw);
  }

  @protected
  ContactOrderType dco_decode_contact_order_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ContactOrderType.values[raw as int];
  }

  @protected
  ContactsDetailBase dco_decode_contacts_detail_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 20)
      throw Exception('unexpected arr length: expect 20 but see ${arr.length}');
    return ContactsDetailBase(
      userInfo: dco_decode_opt_box_autoadd_user_base(arr[0]),
      depict: dco_decode_String(arr[1]),
      bfStar: dco_decode_bool(arr[2]),
      bfDisturb: dco_decode_bool(arr[3]),
      bfMyBlack: dco_decode_bool(arr[4]),
      letter: dco_decode_String(arr[5]),
      bfTop: dco_decode_bool(arr[6]),
      bfVerify: dco_decode_bool(arr[7]),
      signature: dco_decode_String(arr[8]),
      groupNickName: dco_decode_String(arr[9]),
      phone: dco_decode_String(arr[10]),
      bfReadCancel: dco_decode_bool(arr[11]),
      msgCancelTime: dco_decode_i_32(arr[12]),
      bfScreenshot: dco_decode_bool(arr[13]),
      commonGroupNum: dco_decode_i_32(arr[14]),
      bfReadReceipt: dco_decode_bool(arr[15]),
      groupShutupTime: dco_decode_i_32(arr[16]),
      searchType: dco_decode_i_32(arr[17]),
      addToken: dco_decode_String(arr[18]),
      bfIdSearch: dco_decode_bool(arr[19]),
    );
  }

  @protected
  ContactsOperator dco_decode_contacts_operator(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ContactsOperator.values[raw as int];
  }

  @protected
  ContactsParam dco_decode_contacts_param(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ContactsParam(
      contactsId: dco_decode_i_64(arr[0]),
      noteName: dco_decode_String(arr[1]),
      depict: dco_decode_String(arr[2]),
      bfStar: dco_decode_bool(arr[3]),
      bfDisturb: dco_decode_bool(arr[4]),
      bfTop: dco_decode_bool(arr[5]),
      bfReadCancel: dco_decode_bool(arr[6]),
      msgCancelTime: dco_decode_i_32(arr[7]),
      bfScreenshot: dco_decode_bool(arr[8]),
    );
  }

  @protected
  DownloadProgressInfo dco_decode_download_progress_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DownloadProgressInfo(
      downloadedBytes: dco_decode_i_64(arr[0]),
      totalBytes: dco_decode_opt_box_autoadd_i_64(arr[1]),
      progressPercentage: dco_decode_f_64(arr[2]),
      url: dco_decode_String(arr[3]),
    );
  }

  @protected
  DownloadResult dco_decode_download_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return DownloadResult(
      success: dco_decode_bool(arr[0]),
      filePath: dco_decode_String(arr[1]),
      errorMessage: dco_decode_opt_String(arr[2]),
      fileSize: dco_decode_i_64(arr[3]),
      wasDecompressed: dco_decode_bool(arr[4]),
      wasSkipped: dco_decode_bool(arr[5]),
      downloadDurationMs: dco_decode_u_64(arr[6]),
      fileHash: dco_decode_opt_String(arr[7]),
    );
  }

  @protected
  DownloadTask dco_decode_download_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return DownloadTask(
      downloadType: dco_decode_download_type(arr[0]),
      url: dco_decode_String(arr[1]),
      baseUrl: dco_decode_opt_String(arr[2]),
      endpoint: dco_decode_opt_String(arr[3]),
      savePath: dco_decode_String(arr[4]),
      autoUnzip: dco_decode_bool(arr[5]),
      customHeaders: dco_decode_opt_Map_String_String_None(arr[6]),
    );
  }

  @protected
  DownloadTaskEnhanced dco_decode_download_task_enhanced(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return DownloadTaskEnhanced(
      downloadType: dco_decode_download_type(arr[0]),
      url: dco_decode_String(arr[1]),
      baseUrl: dco_decode_opt_String(arr[2]),
      endpoint: dco_decode_opt_String(arr[3]),
      savePath: dco_decode_String(arr[4]),
      autoUnzip: dco_decode_bool(arr[5]),
      customHeaders: dco_decode_opt_Map_String_String_None(arr[6]),
      overwritePolicy: dco_decode_file_overwrite_policy(arr[7]),
      calculateHash: dco_decode_bool(arr[8]),
    );
  }

  @protected
  DownloadType dco_decode_download_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DownloadType.values[raw as int];
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FfiAnimatedGameConfig dco_decode_ffi_animated_game_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return FfiAnimatedGameConfig(
      gameId: dco_decode_i_32(arr[0]),
      gameName: dco_decode_String(arr[1]),
      isDisplay: dco_decode_bool(arr[2]),
      downUrl: dco_decode_String(arr[3]),
      iconName: dco_decode_String(arr[4]),
      startGifName: dco_decode_String(arr[5]),
      repeatGifName: dco_decode_String(arr[6]),
      resultGifName: dco_decode_String(arr[7]),
      width: dco_decode_f_64(arr[8]),
      height: dco_decode_f_64(arr[9]),
    );
  }

  @protected
  FfiAnmatedMessageContent dco_decode_ffi_anmated_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FfiAnmatedMessageContent(
      gameId: dco_decode_i_32(arr[0]),
      currentImage: dco_decode_String(arr[1]),
    );
  }

  @protected
  FfiAudioMessageContent dco_decode_ffi_audio_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FfiAudioMessageContent(
      duration: dco_decode_i_32(arr[0]),
      fileSize: dco_decode_i_64(arr[1]),
      url: dco_decode_String(arr[2]),
      waveData: dco_decode_String(arr[3]),
    );
  }

  @protected
  FfiChannelModel dco_decode_ffi_channel_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return FfiChannelModel(
      channelId: dco_decode_i_64(arr[0]),
      channelName: dco_decode_String(arr[1]),
      icon: dco_decode_String(arr[2]),
      logoColor: dco_decode_String(arr[3]),
      adminPrivacy: dco_decode_opt_box_autoadd_i_32(arr[4]),
      createTime: dco_decode_opt_box_autoadd_i_64(arr[5]),
      rateLimit: dco_decode_opt_box_autoadd_i_32(arr[6]),
      unit: dco_decode_opt_box_autoadd_i_32(arr[7]),
    );
  }

  @protected
  FfiChatTransferMessageContent dco_decode_ffi_chat_transfer_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return FfiChatTransferMessageContent(
      transferNo: dco_decode_String(arr[0]),
      count: dco_decode_String(arr[1]),
      coinName: dco_decode_String(arr[2]),
      status: dco_decode_i_32(arr[3]),
      expiredTime: dco_decode_i_64(arr[4]),
      receiverId: dco_decode_i_64(arr[5]),
      receiverName: dco_decode_String(arr[6]),
      issuerUid: dco_decode_i_64(arr[7]),
      issuerName: dco_decode_String(arr[8]),
      issuerIcon: dco_decode_String(arr[9]),
      remark: dco_decode_String(arr[10]),
      plusOneWithhold: dco_decode_i_32(arr[11]),
    );
  }

  @protected
  FfiChatType dco_decode_ffi_chat_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiChatType.values[raw as int];
  }

  @protected
  FfiClientInfo dco_decode_ffi_client_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return FfiClientInfo(
      sessionId: dco_decode_String(arr[0]),
      appVer: dco_decode_i_32(arr[1]),
      packageCode: dco_decode_i_32(arr[2]),
      plat: dco_decode_i_32(arr[3]),
      language: dco_decode_i_32(arr[4]),
      sysMac: dco_decode_String(arr[5]),
      sysModel: dco_decode_String(arr[6]),
    );
  }

  @protected
  FfiCommonMessageModel dco_decode_ffi_common_message_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return FfiCommonMessageModel(
      flag: dco_decode_i_64(arr[0]),
      msgId: dco_decode_i_64(arr[1]),
      targetId: dco_decode_i_64(arr[2]),
      chatType: dco_decode_ffi_chat_type(arr[3]),
      conversationId: dco_decode_String(arr[4]),
      msgType: dco_decode_ffi_msg_type(arr[5]),
      sendTime: dco_decode_i_64(arr[6]),
      serverReceiveTime: dco_decode_i_64(arr[7]),
      receiveTime: dco_decode_i_64(arr[8]),
    );
  }

  @protected
  FfiContactDetail dco_decode_ffi_contact_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 20)
      throw Exception('unexpected arr length: expect 20 but see ${arr.length}');
    return FfiContactDetail(
      userId: dco_decode_i_64(arr[0]),
      nickName: dco_decode_String(arr[1]),
      avatar: dco_decode_String(arr[2]),
      depict: dco_decode_String(arr[3]),
      bfStar: dco_decode_bool(arr[4]),
      bfDisturb: dco_decode_bool(arr[5]),
      bfMyBlack: dco_decode_bool(arr[6]),
      letter: dco_decode_String(arr[7]),
      bfTop: dco_decode_bool(arr[8]),
      bfVerify: dco_decode_bool(arr[9]),
      signature: dco_decode_String(arr[10]),
      groupNickName: dco_decode_String(arr[11]),
      phone: dco_decode_String(arr[12]),
      bfReadCancel: dco_decode_bool(arr[13]),
      msgCancelTime: dco_decode_i_32(arr[14]),
      bfScreenshot: dco_decode_bool(arr[15]),
      commonGroupNum: dco_decode_i_32(arr[16]),
      bfReadReceipt: dco_decode_bool(arr[17]),
      groupShutupTime: dco_decode_i_32(arr[18]),
      searchType: dco_decode_i_32(arr[19]),
    );
  }

  @protected
  FfiConversation dco_decode_ffi_conversation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return FfiConversation(
      conversationId: dco_decode_String(arr[0]),
      chatType: dco_decode_ffi_chat_type(arr[1]),
      targetId: dco_decode_i_64(arr[2]),
      lastMessage: dco_decode_String(arr[3]),
      lastMessageTime: dco_decode_i_64(arr[4]),
      lastMessageType: dco_decode_ffi_msg_type(arr[5]),
      senderUid: dco_decode_i_64(arr[6]),
      senderName: dco_decode_String(arr[7]),
      name: dco_decode_String(arr[8]),
      avatar: dco_decode_opt_String(arr[9]),
      unreadCount: dco_decode_i_32(arr[10]),
      isTopPinned: dco_decode_bool(arr[11]),
      isMuted: dco_decode_bool(arr[12]),
      topPinnedAt: dco_decode_opt_box_autoadd_i_64(arr[13]),
      isArchive: dco_decode_bool(arr[14]),
    );
  }

  @protected
  FfiDiceMessageContent dco_decode_ffi_dice_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FfiDiceMessageContent(
      setImageId: dco_decode_i_64(arr[0]),
      imageSize: dco_decode_i_32(arr[1]),
      currentImage: dco_decode_i_32(arr[2]),
    );
  }

  @protected
  FfiDynamicImageMessageContent dco_decode_ffi_dynamic_image_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return FfiDynamicImageMessageContent(
      width: dco_decode_i_32(arr[0]),
      height: dco_decode_i_32(arr[1]),
      fileSize: dco_decode_i_64(arr[2]),
      url: dco_decode_String(arr[3]),
      thumbUrl: dco_decode_String(arr[4]),
      emoticonId: dco_decode_i_64(arr[5]),
    );
  }

  @protected
  FfiEmoticonBase dco_decode_ffi_emoticon_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return FfiEmoticonBase(
      emotionType: dco_decode_ffi_emotion_info_type(arr[0]),
      imgName: dco_decode_String(arr[1]),
      gameId: dco_decode_opt_box_autoadd_i_32(arr[2]),
      gameIconPath: dco_decode_String(arr[3]),
      emoticonUrl: dco_decode_String(arr[4]),
      emoticonId: dco_decode_i_64(arr[5]),
      width: dco_decode_f_64(arr[6]),
      height: dco_decode_f_64(arr[7]),
    );
  }

  @protected
  FfiEmoticonListResult dco_decode_ffi_emoticon_list_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FfiEmoticonListResult(
      emoticons: dco_decode_list_ffi_emoticon_base(arr[0]),
      count: dco_decode_i_32(arr[1]),
      fromCache: dco_decode_bool(arr[2]),
      lastUpdateTime: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  FfiEmotionInfoType dco_decode_ffi_emotion_info_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiEmotionInfoType.values[raw as int];
  }

  @protected
  FfiFileMessageContent dco_decode_ffi_file_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FfiFileMessageContent(
      size: dco_decode_i_64(arr[0]),
      fileUrl: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
      mimeType: dco_decode_String(arr[3]),
    );
  }

  @protected
  FfiGetEmoticonResponse dco_decode_ffi_get_emoticon_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FfiGetEmoticonResponse(
      emoticons: dco_decode_list_ffi_emoticon_base(arr[0]),
      count: dco_decode_i_32(arr[1]),
      fromCache: dco_decode_bool(arr[2]),
    );
  }

  @protected
  FfiGroupBase dco_decode_ffi_group_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return FfiGroupBase(
      groupId: dco_decode_i_64(arr[0]),
      hostId: dco_decode_i_64(arr[1]),
      name: dco_decode_String(arr[2]),
      pic: dco_decode_String(arr[3]),
      bfJoinCheck: dco_decode_bool(arr[4]),
      createTime: dco_decode_i_64(arr[5]),
      memberCount: dco_decode_i_64(arr[6]),
      bfJoinFriend: dco_decode_bool(arr[7]),
      bfShutup: dco_decode_bool(arr[8]),
      bfGroupReadCancel: dco_decode_bool(arr[9]),
      groupMsgCancelTime: dco_decode_i_32(arr[10]),
      bfBanned: dco_decode_bool(arr[11]),
      groupAliasName: dco_decode_String(arr[12]),
    );
  }

  @protected
  FfiGroupDetailResponse dco_decode_ffi_group_detail_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return FfiGroupDetailResponse(
      group: dco_decode_opt_box_autoadd_ffi_group_base(arr[0]),
      groupNickName: dco_decode_String(arr[1]),
      bfTop: dco_decode_bool(arr[2]),
      bfStar: dco_decode_bool(arr[3]),
      bfDisturb: dco_decode_bool(arr[4]),
      bfAddress: dco_decode_bool(arr[5]),
      memberType: dco_decode_i_32(arr[6]),
      bfMember: dco_decode_bool(arr[7]),
      qrUrl: dco_decode_String(arr[8]),
      qrExpire: dco_decode_i_64(arr[9]),
      bfResetQrcode: dco_decode_bool(arr[10]),
    );
  }

  @protected
  FfiGroupEventMessageContent dco_decode_ffi_group_event_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FfiGroupEventMessageContent(
      rawMsgType: dco_decode_i_32(arr[0]),
      rawContent: dco_decode_String(arr[1]),
    );
  }

  @protected
  FfiHtml2MessageContent dco_decode_ffi_html_2_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiHtml2MessageContent(htmlContent: dco_decode_String(arr[0]));
  }

  @protected
  FfiHtmlMessageContent dco_decode_ffi_html_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiHtmlMessageContent(htmlContent: dco_decode_String(arr[0]));
  }

  @protected
  FfiImageMessageContent dco_decode_ffi_image_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return FfiImageMessageContent(
      width: dco_decode_i_32(arr[0]),
      height: dco_decode_i_32(arr[1]),
      fileSize: dco_decode_i_64(arr[2]),
      url: dco_decode_String(arr[3]),
      thumbUrl: dco_decode_String(arr[4]),
      sizeType: dco_decode_i_32(arr[5]),
    );
  }

  @protected
  FfiInitParams dco_decode_ffi_init_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return FfiInitParams(
      baseDir: dco_decode_String(arr[0]),
      secretKeyName: dco_decode_String(arr[1]),
      secretKeyValue: dco_decode_String(arr[2]),
      embedDomianHost: dco_decode_String(arr[3]),
      embedDomainOssUrl: dco_decode_String(arr[4]),
      embedLoginHost: dco_decode_String(arr[5]),
      embedLoginOssUrl: dco_decode_String(arr[6]),
    );
  }

  @protected
  FfiLocationMessageContent dco_decode_ffi_location_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FfiLocationMessageContent(
      lat: dco_decode_i_64(arr[0]),
      lng: dco_decode_i_64(arr[1]),
      address: dco_decode_String(arr[2]),
    );
  }

  @protected
  FfiLoginResponse dco_decode_ffi_login_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return FfiLoginResponse(
      user: dco_decode_opt_box_autoadd_ffi_user_base(arr[0]),
      sessionId: dco_decode_String(arr[1]),
      urls: dco_decode_opt_box_autoadd_ffi_url_info(arr[2]),
      serverTime: dco_decode_i_64(arr[3]),
      token: dco_decode_String(arr[4]),
      inviteCode: dco_decode_String(arr[5]),
    );
  }

  @protected
  FfiMediasCaptionMessageContent dco_decode_ffi_medias_caption_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiMediasCaptionMessageContent(caption: dco_decode_String(arr[0]));
  }

  @protected
  FfiMessageMetaData dco_decode_ffi_message_meta_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return FfiMessageMetaData(
      chatType: dco_decode_ffi_chat_type(arr[0]),
      targetId: dco_decode_i_64(arr[1]),
      msgTypeVal: dco_decode_i_32(arr[2]),
      senderUid: dco_decode_i_64(arr[3]),
      senderNickName: dco_decode_String(arr[4]),
      senderAvatar: dco_decode_opt_String(arr[5]),
      msgId: dco_decode_i_64(arr[6]),
      sendTime: dco_decode_i_64(arr[7]),
      content: dco_decode_list_prim_u_8_strict(arr[8]),
    );
  }

  @protected
  FfiMessageModel dco_decode_ffi_message_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return FfiMessageModel(
      common: dco_decode_ffi_common_message_model(arr[0]),
      contentObj: dco_decode_opt_String(arr[1]),
      senderUser: dco_decode_ffi_message_user(arr[2]),
      refObj: dco_decode_opt_box_autoadd_ffi_reference_obj(arr[3]),
      isSendByMe: dco_decode_bool(arr[4]),
      isRead: dco_decode_bool(arr[5]),
      status: dco_decode_ffi_msg_status(arr[6]),
    );
  }

  @protected
  FfiMessageUser dco_decode_ffi_message_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FfiMessageUser(
      senderUid: dco_decode_i_64(arr[0]),
      senderNickName: dco_decode_String(arr[1]),
      senderAvatar: dco_decode_opt_String(arr[2]),
      remarkName: dco_decode_String(arr[3]),
    );
  }

  @protected
  FfiMsgContent dco_decode_ffi_msg_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FfiMsgContent_Text(
          dco_decode_box_autoadd_ffi_text_message_content(raw[1]),
        );
      case 1:
        return FfiMsgContent_Image(
          dco_decode_box_autoadd_ffi_image_message_content(raw[1]),
        );
      case 2:
        return FfiMsgContent_Image2(
          dco_decode_box_autoadd_ffi_dynamic_image_message_content(raw[1]),
        );
      case 3:
        return FfiMsgContent_Audio(
          dco_decode_box_autoadd_ffi_audio_message_content(raw[1]),
        );
      case 4:
        return FfiMsgContent_Video(
          dco_decode_box_autoadd_ffi_video_message_content(raw[1]),
        );
      case 5:
        return FfiMsgContent_File(
          dco_decode_box_autoadd_ffi_file_message_content(raw[1]),
        );
      case 6:
        return FfiMsgContent_Card(
          dco_decode_box_autoadd_ffi_name_card_message_content(raw[1]),
        );
      case 7:
        return FfiMsgContent_System(
          dco_decode_box_autoadd_ffi_system_message_content(raw[1]),
        );
      case 8:
        return FfiMsgContent_Dice(
          dco_decode_box_autoadd_ffi_dice_message_content(raw[1]),
        );
      case 9:
        return FfiMsgContent_Notice(
          dco_decode_box_autoadd_ffi_notice_message_content(raw[1]),
        );
      case 10:
        return FfiMsgContent_Location(
          dco_decode_box_autoadd_ffi_location_message_content(raw[1]),
        );
      case 11:
        return FfiMsgContent_Packet(
          dco_decode_box_autoadd_ffi_red_packet_message_content(raw[1]),
        );
      case 12:
        return FfiMsgContent_Transfer(
          dco_decode_box_autoadd_ffi_chat_transfer_message_content(raw[1]),
        );
      case 13:
        return FfiMsgContent_Medias(
          dco_decode_box_autoadd_ffi_medias_caption_message_content(raw[1]),
        );
      case 14:
        return FfiMsgContent_Game(
          dco_decode_box_autoadd_ffi_anmated_message_content(raw[1]),
        );
      case 15:
        return FfiMsgContent_Html(
          dco_decode_box_autoadd_ffi_html_message_content(raw[1]),
        );
      case 16:
        return FfiMsgContent_Html2(
          dco_decode_box_autoadd_ffi_html_2_message_content(raw[1]),
        );
      case 17:
        return FfiMsgContent_GroupEvent(
          dco_decode_box_autoadd_ffi_group_event_message_content(raw[1]),
        );
      case 18:
        return FfiMsgContent_Unknown(
          dco_decode_box_autoadd_ffi_unknown_message_content(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FfiMsgStatus dco_decode_ffi_msg_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiMsgStatus.values[raw as int];
  }

  @protected
  FfiMsgType dco_decode_ffi_msg_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiMsgType.values[raw as int];
  }

  @protected
  FfiNameCardMessageContent dco_decode_ffi_name_card_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FfiNameCardMessageContent(
      uid: dco_decode_i_64(arr[0]),
      nickName: dco_decode_String(arr[1]),
      icon: dco_decode_String(arr[2]),
      identify: dco_decode_String(arr[3]),
    );
  }

  @protected
  FfiNoticeMessageContent dco_decode_ffi_notice_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FfiNoticeMessageContent(
      content: dco_decode_String(arr[0]),
      noticeId: dco_decode_i_64(arr[1]),
      showNotify: dco_decode_bool(arr[2]),
    );
  }

  @protected
  FfiPushNotificationType dco_decode_ffi_push_notification_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiPushNotificationType.values[raw as int];
  }

  @protected
  FfiRedPacketMessageContent dco_decode_ffi_red_packet_message_content(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 16)
      throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
    return FfiRedPacketMessageContent(
      redPacketId: dco_decode_String(arr[0]),
      status: dco_decode_i_32(arr[1]),
      expiredTime: dco_decode_i_64(arr[2]),
      type: dco_decode_i_32(arr[3]),
      count: dco_decode_i_32(arr[4]),
      receiverId: dco_decode_i_64(arr[5]),
      receiverName: dco_decode_String(arr[6]),
      issuerUid: dco_decode_i_64(arr[7]),
      issuerName: dco_decode_String(arr[8]),
      issuerIcon: dco_decode_String(arr[9]),
      luckyWord: dco_decode_String(arr[10]),
      luckyImageUrl: dco_decode_String(arr[11]),
      openedCoverUrl: dco_decode_String(arr[12]),
      unOpenedCoverUrl: dco_decode_String(arr[13]),
      coverExpireTime: dco_decode_i_64(arr[14]),
      plusOneWithhold: dco_decode_i_32(arr[15]),
    );
  }

  @protected
  FfiReferenceObj dco_decode_ffi_reference_obj(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return FfiReferenceObj(
      msgId: dco_decode_i_64(arr[0]),
      content: dco_decode_String(arr[1]),
      msgType: dco_decode_ffi_msg_type(arr[2]),
      uid: dco_decode_i_64(arr[3]),
      nickname: dco_decode_String(arr[4]),
    );
  }

  @protected
  FfiRegResponse dco_decode_ffi_reg_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return FfiRegResponse(
      user: dco_decode_opt_box_autoadd_ffi_user_base(arr[0]),
      sessionId: dco_decode_String(arr[1]),
      urls: dco_decode_opt_box_autoadd_ffi_url_info(arr[2]),
      serverTime: dco_decode_i_64(arr[3]),
      token: dco_decode_String(arr[4]),
      inviteCode: dco_decode_String(arr[5]),
      keyVersion: dco_decode_i_32(arr[6]),
    );
  }

  @protected
  FfiSystemMessageContent dco_decode_ffi_system_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiSystemMessageContent(content: dco_decode_String(arr[0]));
  }

  @protected
  FfiTextMessageContent dco_decode_ffi_text_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiTextMessageContent(text: dco_decode_String(arr[0]));
  }

  @protected
  FfiUnknownMessageContent dco_decode_ffi_unknown_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FfiUnknownMessageContent(
      rawMsgType: dco_decode_i_32(arr[0]),
      rawContent: dco_decode_String(arr[1]),
    );
  }

  @protected
  FfiUrlInfo dco_decode_ffi_url_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 17)
      throw Exception('unexpected arr length: expect 17 but see ${arr.length}');
    return FfiUrlInfo(
      biz: dco_decode_String(arr[0]),
      session: dco_decode_String(arr[1]),
      friend: dco_decode_String(arr[2]),
      group: dco_decode_String(arr[3]),
      staticMap: dco_decode_String(arr[4]),
      download: dco_decode_String(arr[5]),
      login: dco_decode_String(arr[6]),
      config: dco_decode_String(arr[7]),
      wss: dco_decode_String(arr[8]),
      socketProtocol: dco_decode_i_32(arr[9]),
      uploadServer: dco_decode_i_32(arr[10]),
      uploadUrl: dco_decode_String(arr[11]),
      walletUrl: dco_decode_String(arr[12]),
      newsUrl: dco_decode_String(arr[13]),
      otcUrl: dco_decode_String(arr[14]),
      redPacketUrl: dco_decode_String(arr[15]),
      paymentUrl: dco_decode_String(arr[16]),
    );
  }

  @protected
  FfiUser dco_decode_ffi_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return FfiUser(
      uid: dco_decode_i_64(arr[0]),
      nickName: dco_decode_opt_String(arr[1]),
      icon: dco_decode_opt_String(arr[2]),
      privacy: dco_decode_opt_box_autoadd_i_32(arr[3]),
      gender: dco_decode_opt_box_autoadd_i_32(arr[4]),
      signature: dco_decode_opt_String(arr[5]),
      viewType: dco_decode_opt_box_autoadd_i_32(arr[6]),
      language: dco_decode_opt_box_autoadd_i_32(arr[7]),
      clearTime: dco_decode_opt_box_autoadd_i_32(arr[8]),
      identify: dco_decode_opt_String(arr[9]),
      phone: dco_decode_opt_String(arr[10]),
      email: dco_decode_opt_String(arr[11]),
    );
  }

  @protected
  FfiUserBase dco_decode_ffi_user_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FfiUserBase(
      uid: dco_decode_i_64(arr[0]),
      nickName: dco_decode_String(arr[1]),
      avatar: dco_decode_String(arr[2]),
    );
  }

  @protected
  FfiVideoMessageContent dco_decode_ffi_video_message_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return FfiVideoMessageContent(
      width: dco_decode_i_32(arr[0]),
      height: dco_decode_i_32(arr[1]),
      fileSize: dco_decode_i_64(arr[2]),
      url: dco_decode_String(arr[3]),
      thumbUrl: dco_decode_String(arr[4]),
      duration: dco_decode_i_32(arr[5]),
    );
  }

  @protected
  FileOverwritePolicy dco_decode_file_overwrite_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FileOverwritePolicy.values[raw as int];
  }

  @protected
  FriendRelation dco_decode_friend_relation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FriendRelation(
      bfFriend: dco_decode_bool(arr[0]),
      remarkName: dco_decode_String(arr[1]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<DownloadResult> dco_decode_list_download_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_download_result).toList();
  }

  @protected
  List<DownloadTask> dco_decode_list_download_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_download_task).toList();
  }

  @protected
  List<DownloadTaskEnhanced> dco_decode_list_download_task_enhanced(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_download_task_enhanced)
        .toList();
  }

  @protected
  List<FfiAnimatedGameConfig> dco_decode_list_ffi_animated_game_config(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_ffi_animated_game_config)
        .toList();
  }

  @protected
  List<FfiChannelModel> dco_decode_list_ffi_channel_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_channel_model).toList();
  }

  @protected
  List<FfiContactDetail> dco_decode_list_ffi_contact_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_contact_detail).toList();
  }

  @protected
  List<FfiConversation> dco_decode_list_ffi_conversation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_conversation).toList();
  }

  @protected
  List<FfiEmoticonBase> dco_decode_list_ffi_emoticon_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_emoticon_base).toList();
  }

  @protected
  List<FfiGroupBase> dco_decode_list_ffi_group_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_group_base).toList();
  }

  @protected
  List<FfiMessageModel> dco_decode_list_ffi_message_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_message_model).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(FfiChatType, PlatformInt64)> dco_decode_list_record_ffi_chat_type_i_64(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_ffi_chat_type_i_64)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  MessageError dco_decode_message_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MessageError(message: dco_decode_String(arr[0]));
  }

  @protected
  Map<String, String>? dco_decode_opt_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_Map_String_String_None(raw);
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  FfiChannelModel? dco_decode_opt_box_autoadd_ffi_channel_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_channel_model(raw);
  }

  @protected
  FfiChatType? dco_decode_opt_box_autoadd_ffi_chat_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_chat_type(raw);
  }

  @protected
  FfiConversation? dco_decode_opt_box_autoadd_ffi_conversation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_conversation(raw);
  }

  @protected
  FfiGroupBase? dco_decode_opt_box_autoadd_ffi_group_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_group_base(raw);
  }

  @protected
  FfiReferenceObj? dco_decode_opt_box_autoadd_ffi_reference_obj(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_reference_obj(raw);
  }

  @protected
  FfiUrlInfo? dco_decode_opt_box_autoadd_ffi_url_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_url_info(raw);
  }

  @protected
  FfiUserBase? dco_decode_opt_box_autoadd_ffi_user_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_user_base(raw);
  }

  @protected
  FriendRelation? dco_decode_opt_box_autoadd_friend_relation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_friend_relation(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  UserBase? dco_decode_opt_box_autoadd_user_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_user_base(raw);
  }

  @protected
  UserOnOrOffLine? dco_decode_opt_box_autoadd_user_on_or_off_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_user_on_or_off_line(raw);
  }

  @protected
  (FfiChatType, PlatformInt64) dco_decode_record_ffi_chat_type_i_64(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_ffi_chat_type(arr[0]), dco_decode_i_64(arr[1]));
  }

  @protected
  (String, FfiReferenceObj?)
  dco_decode_record_string_opt_box_autoadd_ffi_reference_obj(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_opt_box_autoadd_ffi_reference_obj(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_String(arr[1]));
  }

  @protected
  Rust2ClientMessagePayload dco_decode_rust_2_client_message_payload(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Rust2ClientMessagePayload(
      messageType: dco_decode_rust_2_client_message_type(arr[0]),
      payload: dco_decode_String(arr[1]),
    );
  }

  @protected
  Rust2ClientMessageType dco_decode_rust_2_client_message_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Rust2ClientMessageType.values[raw as int];
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserBase dco_decode_user_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return UserBase(
      uid: dco_decode_i_64(arr[0]),
      nickName: dco_decode_String(arr[1]),
      icon: dco_decode_String(arr[2]),
      gender: dco_decode_i_32(arr[3]),
      friendRelation: dco_decode_opt_box_autoadd_friend_relation(arr[4]),
      userOnOrOffline: dco_decode_opt_box_autoadd_user_on_or_off_line(arr[5]),
      signature: dco_decode_String(arr[6]),
      depict: dco_decode_String(arr[7]),
      bfCancel: dco_decode_bool(arr[8]),
      bfBanned: dco_decode_bool(arr[9]),
      identify: dco_decode_String(arr[10]),
      realName: dco_decode_String(arr[11]),
      idNumber: dco_decode_String(arr[12]),
      createTime: dco_decode_i_64(arr[13]),
      userType: dco_decode_i_32(arr[14]),
    );
  }

  @protected
  UserOnOrOffLine dco_decode_user_on_or_off_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return UserOnOrOffLine(
      uid: dco_decode_i_64(arr[0]),
      online: dco_decode_bool(arr[1]),
      createTime: dco_decode_i_64(arr[2]),
      bfShow: dco_decode_bool(arr[3]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ArcFfiMessageContentTrait
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcFfiMessageContentTraitImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Map<String, String> sse_decode_Map_String_String_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  ArcFfiMessageContentTrait
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcFfiMessageContentTraitImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FfiUser> sse_decode_StreamSink_ffi_user_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<Rust2ClientMessagePayload>
  sse_decode_StreamSink_rust_2_client_message_payload_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AccountType sse_decode_account_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AccountType.values[inner];
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  ContactsDetailBase sse_decode_box_autoadd_contacts_detail_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_contacts_detail_base(deserializer));
  }

  @protected
  ContactsParam sse_decode_box_autoadd_contacts_param(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_contacts_param(deserializer));
  }

  @protected
  FfiAnmatedMessageContent sse_decode_box_autoadd_ffi_anmated_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_anmated_message_content(deserializer));
  }

  @protected
  FfiAudioMessageContent sse_decode_box_autoadd_ffi_audio_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_audio_message_content(deserializer));
  }

  @protected
  FfiChannelModel sse_decode_box_autoadd_ffi_channel_model(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_channel_model(deserializer));
  }

  @protected
  FfiChatTransferMessageContent
  sse_decode_box_autoadd_ffi_chat_transfer_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_chat_transfer_message_content(deserializer));
  }

  @protected
  FfiChatType sse_decode_box_autoadd_ffi_chat_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_chat_type(deserializer));
  }

  @protected
  FfiClientInfo sse_decode_box_autoadd_ffi_client_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_client_info(deserializer));
  }

  @protected
  FfiConversation sse_decode_box_autoadd_ffi_conversation(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_conversation(deserializer));
  }

  @protected
  FfiDiceMessageContent sse_decode_box_autoadd_ffi_dice_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_dice_message_content(deserializer));
  }

  @protected
  FfiDynamicImageMessageContent
  sse_decode_box_autoadd_ffi_dynamic_image_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_dynamic_image_message_content(deserializer));
  }

  @protected
  FfiFileMessageContent sse_decode_box_autoadd_ffi_file_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_file_message_content(deserializer));
  }

  @protected
  FfiGroupBase sse_decode_box_autoadd_ffi_group_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_group_base(deserializer));
  }

  @protected
  FfiGroupEventMessageContent
  sse_decode_box_autoadd_ffi_group_event_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_group_event_message_content(deserializer));
  }

  @protected
  FfiHtml2MessageContent sse_decode_box_autoadd_ffi_html_2_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_html_2_message_content(deserializer));
  }

  @protected
  FfiHtmlMessageContent sse_decode_box_autoadd_ffi_html_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_html_message_content(deserializer));
  }

  @protected
  FfiImageMessageContent sse_decode_box_autoadd_ffi_image_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_image_message_content(deserializer));
  }

  @protected
  FfiInitParams sse_decode_box_autoadd_ffi_init_params(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_init_params(deserializer));
  }

  @protected
  FfiLocationMessageContent sse_decode_box_autoadd_ffi_location_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_location_message_content(deserializer));
  }

  @protected
  FfiMediasCaptionMessageContent
  sse_decode_box_autoadd_ffi_medias_caption_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_medias_caption_message_content(deserializer));
  }

  @protected
  FfiMessageMetaData sse_decode_box_autoadd_ffi_message_meta_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_message_meta_data(deserializer));
  }

  @protected
  FfiMessageModel sse_decode_box_autoadd_ffi_message_model(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_message_model(deserializer));
  }

  @protected
  FfiMsgContent sse_decode_box_autoadd_ffi_msg_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_msg_content(deserializer));
  }

  @protected
  FfiNameCardMessageContent
  sse_decode_box_autoadd_ffi_name_card_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_name_card_message_content(deserializer));
  }

  @protected
  FfiNoticeMessageContent sse_decode_box_autoadd_ffi_notice_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_notice_message_content(deserializer));
  }

  @protected
  FfiRedPacketMessageContent
  sse_decode_box_autoadd_ffi_red_packet_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_red_packet_message_content(deserializer));
  }

  @protected
  FfiReferenceObj sse_decode_box_autoadd_ffi_reference_obj(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_reference_obj(deserializer));
  }

  @protected
  FfiSystemMessageContent sse_decode_box_autoadd_ffi_system_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_system_message_content(deserializer));
  }

  @protected
  FfiTextMessageContent sse_decode_box_autoadd_ffi_text_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_text_message_content(deserializer));
  }

  @protected
  FfiUnknownMessageContent sse_decode_box_autoadd_ffi_unknown_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_unknown_message_content(deserializer));
  }

  @protected
  FfiUrlInfo sse_decode_box_autoadd_ffi_url_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_url_info(deserializer));
  }

  @protected
  FfiUser sse_decode_box_autoadd_ffi_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_user(deserializer));
  }

  @protected
  FfiUserBase sse_decode_box_autoadd_ffi_user_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_user_base(deserializer));
  }

  @protected
  FfiVideoMessageContent sse_decode_box_autoadd_ffi_video_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_video_message_content(deserializer));
  }

  @protected
  FriendRelation sse_decode_box_autoadd_friend_relation(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_friend_relation(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  UserBase sse_decode_box_autoadd_user_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_base(deserializer));
  }

  @protected
  UserOnOrOffLine sse_decode_box_autoadd_user_on_or_off_line(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_on_or_off_line(deserializer));
  }

  @protected
  ContactOrderType sse_decode_contact_order_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ContactOrderType.values[inner];
  }

  @protected
  ContactsDetailBase sse_decode_contacts_detail_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userInfo = sse_decode_opt_box_autoadd_user_base(deserializer);
    var var_depict = sse_decode_String(deserializer);
    var var_bfStar = sse_decode_bool(deserializer);
    var var_bfDisturb = sse_decode_bool(deserializer);
    var var_bfMyBlack = sse_decode_bool(deserializer);
    var var_letter = sse_decode_String(deserializer);
    var var_bfTop = sse_decode_bool(deserializer);
    var var_bfVerify = sse_decode_bool(deserializer);
    var var_signature = sse_decode_String(deserializer);
    var var_groupNickName = sse_decode_String(deserializer);
    var var_phone = sse_decode_String(deserializer);
    var var_bfReadCancel = sse_decode_bool(deserializer);
    var var_msgCancelTime = sse_decode_i_32(deserializer);
    var var_bfScreenshot = sse_decode_bool(deserializer);
    var var_commonGroupNum = sse_decode_i_32(deserializer);
    var var_bfReadReceipt = sse_decode_bool(deserializer);
    var var_groupShutupTime = sse_decode_i_32(deserializer);
    var var_searchType = sse_decode_i_32(deserializer);
    var var_addToken = sse_decode_String(deserializer);
    var var_bfIdSearch = sse_decode_bool(deserializer);
    return ContactsDetailBase(
      userInfo: var_userInfo,
      depict: var_depict,
      bfStar: var_bfStar,
      bfDisturb: var_bfDisturb,
      bfMyBlack: var_bfMyBlack,
      letter: var_letter,
      bfTop: var_bfTop,
      bfVerify: var_bfVerify,
      signature: var_signature,
      groupNickName: var_groupNickName,
      phone: var_phone,
      bfReadCancel: var_bfReadCancel,
      msgCancelTime: var_msgCancelTime,
      bfScreenshot: var_bfScreenshot,
      commonGroupNum: var_commonGroupNum,
      bfReadReceipt: var_bfReadReceipt,
      groupShutupTime: var_groupShutupTime,
      searchType: var_searchType,
      addToken: var_addToken,
      bfIdSearch: var_bfIdSearch,
    );
  }

  @protected
  ContactsOperator sse_decode_contacts_operator(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ContactsOperator.values[inner];
  }

  @protected
  ContactsParam sse_decode_contacts_param(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_contactsId = sse_decode_i_64(deserializer);
    var var_noteName = sse_decode_String(deserializer);
    var var_depict = sse_decode_String(deserializer);
    var var_bfStar = sse_decode_bool(deserializer);
    var var_bfDisturb = sse_decode_bool(deserializer);
    var var_bfTop = sse_decode_bool(deserializer);
    var var_bfReadCancel = sse_decode_bool(deserializer);
    var var_msgCancelTime = sse_decode_i_32(deserializer);
    var var_bfScreenshot = sse_decode_bool(deserializer);
    return ContactsParam(
      contactsId: var_contactsId,
      noteName: var_noteName,
      depict: var_depict,
      bfStar: var_bfStar,
      bfDisturb: var_bfDisturb,
      bfTop: var_bfTop,
      bfReadCancel: var_bfReadCancel,
      msgCancelTime: var_msgCancelTime,
      bfScreenshot: var_bfScreenshot,
    );
  }

  @protected
  DownloadProgressInfo sse_decode_download_progress_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_downloadedBytes = sse_decode_i_64(deserializer);
    var var_totalBytes = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_progressPercentage = sse_decode_f_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    return DownloadProgressInfo(
      downloadedBytes: var_downloadedBytes,
      totalBytes: var_totalBytes,
      progressPercentage: var_progressPercentage,
      url: var_url,
    );
  }

  @protected
  DownloadResult sse_decode_download_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_success = sse_decode_bool(deserializer);
    var var_filePath = sse_decode_String(deserializer);
    var var_errorMessage = sse_decode_opt_String(deserializer);
    var var_fileSize = sse_decode_i_64(deserializer);
    var var_wasDecompressed = sse_decode_bool(deserializer);
    var var_wasSkipped = sse_decode_bool(deserializer);
    var var_downloadDurationMs = sse_decode_u_64(deserializer);
    var var_fileHash = sse_decode_opt_String(deserializer);
    return DownloadResult(
      success: var_success,
      filePath: var_filePath,
      errorMessage: var_errorMessage,
      fileSize: var_fileSize,
      wasDecompressed: var_wasDecompressed,
      wasSkipped: var_wasSkipped,
      downloadDurationMs: var_downloadDurationMs,
      fileHash: var_fileHash,
    );
  }

  @protected
  DownloadTask sse_decode_download_task(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_downloadType = sse_decode_download_type(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_baseUrl = sse_decode_opt_String(deserializer);
    var var_endpoint = sse_decode_opt_String(deserializer);
    var var_savePath = sse_decode_String(deserializer);
    var var_autoUnzip = sse_decode_bool(deserializer);
    var var_customHeaders = sse_decode_opt_Map_String_String_None(deserializer);
    return DownloadTask(
      downloadType: var_downloadType,
      url: var_url,
      baseUrl: var_baseUrl,
      endpoint: var_endpoint,
      savePath: var_savePath,
      autoUnzip: var_autoUnzip,
      customHeaders: var_customHeaders,
    );
  }

  @protected
  DownloadTaskEnhanced sse_decode_download_task_enhanced(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_downloadType = sse_decode_download_type(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_baseUrl = sse_decode_opt_String(deserializer);
    var var_endpoint = sse_decode_opt_String(deserializer);
    var var_savePath = sse_decode_String(deserializer);
    var var_autoUnzip = sse_decode_bool(deserializer);
    var var_customHeaders = sse_decode_opt_Map_String_String_None(deserializer);
    var var_overwritePolicy = sse_decode_file_overwrite_policy(deserializer);
    var var_calculateHash = sse_decode_bool(deserializer);
    return DownloadTaskEnhanced(
      downloadType: var_downloadType,
      url: var_url,
      baseUrl: var_baseUrl,
      endpoint: var_endpoint,
      savePath: var_savePath,
      autoUnzip: var_autoUnzip,
      customHeaders: var_customHeaders,
      overwritePolicy: var_overwritePolicy,
      calculateHash: var_calculateHash,
    );
  }

  @protected
  DownloadType sse_decode_download_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DownloadType.values[inner];
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FfiAnimatedGameConfig sse_decode_ffi_animated_game_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gameId = sse_decode_i_32(deserializer);
    var var_gameName = sse_decode_String(deserializer);
    var var_isDisplay = sse_decode_bool(deserializer);
    var var_downUrl = sse_decode_String(deserializer);
    var var_iconName = sse_decode_String(deserializer);
    var var_startGifName = sse_decode_String(deserializer);
    var var_repeatGifName = sse_decode_String(deserializer);
    var var_resultGifName = sse_decode_String(deserializer);
    var var_width = sse_decode_f_64(deserializer);
    var var_height = sse_decode_f_64(deserializer);
    return FfiAnimatedGameConfig(
      gameId: var_gameId,
      gameName: var_gameName,
      isDisplay: var_isDisplay,
      downUrl: var_downUrl,
      iconName: var_iconName,
      startGifName: var_startGifName,
      repeatGifName: var_repeatGifName,
      resultGifName: var_resultGifName,
      width: var_width,
      height: var_height,
    );
  }

  @protected
  FfiAnmatedMessageContent sse_decode_ffi_anmated_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gameId = sse_decode_i_32(deserializer);
    var var_currentImage = sse_decode_String(deserializer);
    return FfiAnmatedMessageContent(
      gameId: var_gameId,
      currentImage: var_currentImage,
    );
  }

  @protected
  FfiAudioMessageContent sse_decode_ffi_audio_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_duration = sse_decode_i_32(deserializer);
    var var_fileSize = sse_decode_i_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_waveData = sse_decode_String(deserializer);
    return FfiAudioMessageContent(
      duration: var_duration,
      fileSize: var_fileSize,
      url: var_url,
      waveData: var_waveData,
    );
  }

  @protected
  FfiChannelModel sse_decode_ffi_channel_model(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channelId = sse_decode_i_64(deserializer);
    var var_channelName = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_logoColor = sse_decode_String(deserializer);
    var var_adminPrivacy = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_createTime = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_rateLimit = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_unit = sse_decode_opt_box_autoadd_i_32(deserializer);
    return FfiChannelModel(
      channelId: var_channelId,
      channelName: var_channelName,
      icon: var_icon,
      logoColor: var_logoColor,
      adminPrivacy: var_adminPrivacy,
      createTime: var_createTime,
      rateLimit: var_rateLimit,
      unit: var_unit,
    );
  }

  @protected
  FfiChatTransferMessageContent sse_decode_ffi_chat_transfer_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transferNo = sse_decode_String(deserializer);
    var var_count = sse_decode_String(deserializer);
    var var_coinName = sse_decode_String(deserializer);
    var var_status = sse_decode_i_32(deserializer);
    var var_expiredTime = sse_decode_i_64(deserializer);
    var var_receiverId = sse_decode_i_64(deserializer);
    var var_receiverName = sse_decode_String(deserializer);
    var var_issuerUid = sse_decode_i_64(deserializer);
    var var_issuerName = sse_decode_String(deserializer);
    var var_issuerIcon = sse_decode_String(deserializer);
    var var_remark = sse_decode_String(deserializer);
    var var_plusOneWithhold = sse_decode_i_32(deserializer);
    return FfiChatTransferMessageContent(
      transferNo: var_transferNo,
      count: var_count,
      coinName: var_coinName,
      status: var_status,
      expiredTime: var_expiredTime,
      receiverId: var_receiverId,
      receiverName: var_receiverName,
      issuerUid: var_issuerUid,
      issuerName: var_issuerName,
      issuerIcon: var_issuerIcon,
      remark: var_remark,
      plusOneWithhold: var_plusOneWithhold,
    );
  }

  @protected
  FfiChatType sse_decode_ffi_chat_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FfiChatType.values[inner];
  }

  @protected
  FfiClientInfo sse_decode_ffi_client_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sessionId = sse_decode_String(deserializer);
    var var_appVer = sse_decode_i_32(deserializer);
    var var_packageCode = sse_decode_i_32(deserializer);
    var var_plat = sse_decode_i_32(deserializer);
    var var_language = sse_decode_i_32(deserializer);
    var var_sysMac = sse_decode_String(deserializer);
    var var_sysModel = sse_decode_String(deserializer);
    return FfiClientInfo(
      sessionId: var_sessionId,
      appVer: var_appVer,
      packageCode: var_packageCode,
      plat: var_plat,
      language: var_language,
      sysMac: var_sysMac,
      sysModel: var_sysModel,
    );
  }

  @protected
  FfiCommonMessageModel sse_decode_ffi_common_message_model(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_flag = sse_decode_i_64(deserializer);
    var var_msgId = sse_decode_i_64(deserializer);
    var var_targetId = sse_decode_i_64(deserializer);
    var var_chatType = sse_decode_ffi_chat_type(deserializer);
    var var_conversationId = sse_decode_String(deserializer);
    var var_msgType = sse_decode_ffi_msg_type(deserializer);
    var var_sendTime = sse_decode_i_64(deserializer);
    var var_serverReceiveTime = sse_decode_i_64(deserializer);
    var var_receiveTime = sse_decode_i_64(deserializer);
    return FfiCommonMessageModel(
      flag: var_flag,
      msgId: var_msgId,
      targetId: var_targetId,
      chatType: var_chatType,
      conversationId: var_conversationId,
      msgType: var_msgType,
      sendTime: var_sendTime,
      serverReceiveTime: var_serverReceiveTime,
      receiveTime: var_receiveTime,
    );
  }

  @protected
  FfiContactDetail sse_decode_ffi_contact_detail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_i_64(deserializer);
    var var_nickName = sse_decode_String(deserializer);
    var var_avatar = sse_decode_String(deserializer);
    var var_depict = sse_decode_String(deserializer);
    var var_bfStar = sse_decode_bool(deserializer);
    var var_bfDisturb = sse_decode_bool(deserializer);
    var var_bfMyBlack = sse_decode_bool(deserializer);
    var var_letter = sse_decode_String(deserializer);
    var var_bfTop = sse_decode_bool(deserializer);
    var var_bfVerify = sse_decode_bool(deserializer);
    var var_signature = sse_decode_String(deserializer);
    var var_groupNickName = sse_decode_String(deserializer);
    var var_phone = sse_decode_String(deserializer);
    var var_bfReadCancel = sse_decode_bool(deserializer);
    var var_msgCancelTime = sse_decode_i_32(deserializer);
    var var_bfScreenshot = sse_decode_bool(deserializer);
    var var_commonGroupNum = sse_decode_i_32(deserializer);
    var var_bfReadReceipt = sse_decode_bool(deserializer);
    var var_groupShutupTime = sse_decode_i_32(deserializer);
    var var_searchType = sse_decode_i_32(deserializer);
    return FfiContactDetail(
      userId: var_userId,
      nickName: var_nickName,
      avatar: var_avatar,
      depict: var_depict,
      bfStar: var_bfStar,
      bfDisturb: var_bfDisturb,
      bfMyBlack: var_bfMyBlack,
      letter: var_letter,
      bfTop: var_bfTop,
      bfVerify: var_bfVerify,
      signature: var_signature,
      groupNickName: var_groupNickName,
      phone: var_phone,
      bfReadCancel: var_bfReadCancel,
      msgCancelTime: var_msgCancelTime,
      bfScreenshot: var_bfScreenshot,
      commonGroupNum: var_commonGroupNum,
      bfReadReceipt: var_bfReadReceipt,
      groupShutupTime: var_groupShutupTime,
      searchType: var_searchType,
    );
  }

  @protected
  FfiConversation sse_decode_ffi_conversation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_conversationId = sse_decode_String(deserializer);
    var var_chatType = sse_decode_ffi_chat_type(deserializer);
    var var_targetId = sse_decode_i_64(deserializer);
    var var_lastMessage = sse_decode_String(deserializer);
    var var_lastMessageTime = sse_decode_i_64(deserializer);
    var var_lastMessageType = sse_decode_ffi_msg_type(deserializer);
    var var_senderUid = sse_decode_i_64(deserializer);
    var var_senderName = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_avatar = sse_decode_opt_String(deserializer);
    var var_unreadCount = sse_decode_i_32(deserializer);
    var var_isTopPinned = sse_decode_bool(deserializer);
    var var_isMuted = sse_decode_bool(deserializer);
    var var_topPinnedAt = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_isArchive = sse_decode_bool(deserializer);
    return FfiConversation(
      conversationId: var_conversationId,
      chatType: var_chatType,
      targetId: var_targetId,
      lastMessage: var_lastMessage,
      lastMessageTime: var_lastMessageTime,
      lastMessageType: var_lastMessageType,
      senderUid: var_senderUid,
      senderName: var_senderName,
      name: var_name,
      avatar: var_avatar,
      unreadCount: var_unreadCount,
      isTopPinned: var_isTopPinned,
      isMuted: var_isMuted,
      topPinnedAt: var_topPinnedAt,
      isArchive: var_isArchive,
    );
  }

  @protected
  FfiDiceMessageContent sse_decode_ffi_dice_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_setImageId = sse_decode_i_64(deserializer);
    var var_imageSize = sse_decode_i_32(deserializer);
    var var_currentImage = sse_decode_i_32(deserializer);
    return FfiDiceMessageContent(
      setImageId: var_setImageId,
      imageSize: var_imageSize,
      currentImage: var_currentImage,
    );
  }

  @protected
  FfiDynamicImageMessageContent sse_decode_ffi_dynamic_image_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_fileSize = sse_decode_i_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_thumbUrl = sse_decode_String(deserializer);
    var var_emoticonId = sse_decode_i_64(deserializer);
    return FfiDynamicImageMessageContent(
      width: var_width,
      height: var_height,
      fileSize: var_fileSize,
      url: var_url,
      thumbUrl: var_thumbUrl,
      emoticonId: var_emoticonId,
    );
  }

  @protected
  FfiEmoticonBase sse_decode_ffi_emoticon_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_emotionType = sse_decode_ffi_emotion_info_type(deserializer);
    var var_imgName = sse_decode_String(deserializer);
    var var_gameId = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_gameIconPath = sse_decode_String(deserializer);
    var var_emoticonUrl = sse_decode_String(deserializer);
    var var_emoticonId = sse_decode_i_64(deserializer);
    var var_width = sse_decode_f_64(deserializer);
    var var_height = sse_decode_f_64(deserializer);
    return FfiEmoticonBase(
      emotionType: var_emotionType,
      imgName: var_imgName,
      gameId: var_gameId,
      gameIconPath: var_gameIconPath,
      emoticonUrl: var_emoticonUrl,
      emoticonId: var_emoticonId,
      width: var_width,
      height: var_height,
    );
  }

  @protected
  FfiEmoticonListResult sse_decode_ffi_emoticon_list_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_emoticons = sse_decode_list_ffi_emoticon_base(deserializer);
    var var_count = sse_decode_i_32(deserializer);
    var var_fromCache = sse_decode_bool(deserializer);
    var var_lastUpdateTime = sse_decode_u_64(deserializer);
    return FfiEmoticonListResult(
      emoticons: var_emoticons,
      count: var_count,
      fromCache: var_fromCache,
      lastUpdateTime: var_lastUpdateTime,
    );
  }

  @protected
  FfiEmotionInfoType sse_decode_ffi_emotion_info_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FfiEmotionInfoType.values[inner];
  }

  @protected
  FfiFileMessageContent sse_decode_ffi_file_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_size = sse_decode_i_64(deserializer);
    var var_fileUrl = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_mimeType = sse_decode_String(deserializer);
    return FfiFileMessageContent(
      size: var_size,
      fileUrl: var_fileUrl,
      name: var_name,
      mimeType: var_mimeType,
    );
  }

  @protected
  FfiGetEmoticonResponse sse_decode_ffi_get_emoticon_response(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_emoticons = sse_decode_list_ffi_emoticon_base(deserializer);
    var var_count = sse_decode_i_32(deserializer);
    var var_fromCache = sse_decode_bool(deserializer);
    return FfiGetEmoticonResponse(
      emoticons: var_emoticons,
      count: var_count,
      fromCache: var_fromCache,
    );
  }

  @protected
  FfiGroupBase sse_decode_ffi_group_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_i_64(deserializer);
    var var_hostId = sse_decode_i_64(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_pic = sse_decode_String(deserializer);
    var var_bfJoinCheck = sse_decode_bool(deserializer);
    var var_createTime = sse_decode_i_64(deserializer);
    var var_memberCount = sse_decode_i_64(deserializer);
    var var_bfJoinFriend = sse_decode_bool(deserializer);
    var var_bfShutup = sse_decode_bool(deserializer);
    var var_bfGroupReadCancel = sse_decode_bool(deserializer);
    var var_groupMsgCancelTime = sse_decode_i_32(deserializer);
    var var_bfBanned = sse_decode_bool(deserializer);
    var var_groupAliasName = sse_decode_String(deserializer);
    return FfiGroupBase(
      groupId: var_groupId,
      hostId: var_hostId,
      name: var_name,
      pic: var_pic,
      bfJoinCheck: var_bfJoinCheck,
      createTime: var_createTime,
      memberCount: var_memberCount,
      bfJoinFriend: var_bfJoinFriend,
      bfShutup: var_bfShutup,
      bfGroupReadCancel: var_bfGroupReadCancel,
      groupMsgCancelTime: var_groupMsgCancelTime,
      bfBanned: var_bfBanned,
      groupAliasName: var_groupAliasName,
    );
  }

  @protected
  FfiGroupDetailResponse sse_decode_ffi_group_detail_response(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_group = sse_decode_opt_box_autoadd_ffi_group_base(deserializer);
    var var_groupNickName = sse_decode_String(deserializer);
    var var_bfTop = sse_decode_bool(deserializer);
    var var_bfStar = sse_decode_bool(deserializer);
    var var_bfDisturb = sse_decode_bool(deserializer);
    var var_bfAddress = sse_decode_bool(deserializer);
    var var_memberType = sse_decode_i_32(deserializer);
    var var_bfMember = sse_decode_bool(deserializer);
    var var_qrUrl = sse_decode_String(deserializer);
    var var_qrExpire = sse_decode_i_64(deserializer);
    var var_bfResetQrcode = sse_decode_bool(deserializer);
    return FfiGroupDetailResponse(
      group: var_group,
      groupNickName: var_groupNickName,
      bfTop: var_bfTop,
      bfStar: var_bfStar,
      bfDisturb: var_bfDisturb,
      bfAddress: var_bfAddress,
      memberType: var_memberType,
      bfMember: var_bfMember,
      qrUrl: var_qrUrl,
      qrExpire: var_qrExpire,
      bfResetQrcode: var_bfResetQrcode,
    );
  }

  @protected
  FfiGroupEventMessageContent sse_decode_ffi_group_event_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rawMsgType = sse_decode_i_32(deserializer);
    var var_rawContent = sse_decode_String(deserializer);
    return FfiGroupEventMessageContent(
      rawMsgType: var_rawMsgType,
      rawContent: var_rawContent,
    );
  }

  @protected
  FfiHtml2MessageContent sse_decode_ffi_html_2_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_htmlContent = sse_decode_String(deserializer);
    return FfiHtml2MessageContent(htmlContent: var_htmlContent);
  }

  @protected
  FfiHtmlMessageContent sse_decode_ffi_html_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_htmlContent = sse_decode_String(deserializer);
    return FfiHtmlMessageContent(htmlContent: var_htmlContent);
  }

  @protected
  FfiImageMessageContent sse_decode_ffi_image_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_fileSize = sse_decode_i_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_thumbUrl = sse_decode_String(deserializer);
    var var_sizeType = sse_decode_i_32(deserializer);
    return FfiImageMessageContent(
      width: var_width,
      height: var_height,
      fileSize: var_fileSize,
      url: var_url,
      thumbUrl: var_thumbUrl,
      sizeType: var_sizeType,
    );
  }

  @protected
  FfiInitParams sse_decode_ffi_init_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseDir = sse_decode_String(deserializer);
    var var_secretKeyName = sse_decode_String(deserializer);
    var var_secretKeyValue = sse_decode_String(deserializer);
    var var_embedDomianHost = sse_decode_String(deserializer);
    var var_embedDomainOssUrl = sse_decode_String(deserializer);
    var var_embedLoginHost = sse_decode_String(deserializer);
    var var_embedLoginOssUrl = sse_decode_String(deserializer);
    return FfiInitParams(
      baseDir: var_baseDir,
      secretKeyName: var_secretKeyName,
      secretKeyValue: var_secretKeyValue,
      embedDomianHost: var_embedDomianHost,
      embedDomainOssUrl: var_embedDomainOssUrl,
      embedLoginHost: var_embedLoginHost,
      embedLoginOssUrl: var_embedLoginOssUrl,
    );
  }

  @protected
  FfiLocationMessageContent sse_decode_ffi_location_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lat = sse_decode_i_64(deserializer);
    var var_lng = sse_decode_i_64(deserializer);
    var var_address = sse_decode_String(deserializer);
    return FfiLocationMessageContent(
      lat: var_lat,
      lng: var_lng,
      address: var_address,
    );
  }

  @protected
  FfiLoginResponse sse_decode_ffi_login_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_user = sse_decode_opt_box_autoadd_ffi_user_base(deserializer);
    var var_sessionId = sse_decode_String(deserializer);
    var var_urls = sse_decode_opt_box_autoadd_ffi_url_info(deserializer);
    var var_serverTime = sse_decode_i_64(deserializer);
    var var_token = sse_decode_String(deserializer);
    var var_inviteCode = sse_decode_String(deserializer);
    return FfiLoginResponse(
      user: var_user,
      sessionId: var_sessionId,
      urls: var_urls,
      serverTime: var_serverTime,
      token: var_token,
      inviteCode: var_inviteCode,
    );
  }

  @protected
  FfiMediasCaptionMessageContent sse_decode_ffi_medias_caption_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_caption = sse_decode_String(deserializer);
    return FfiMediasCaptionMessageContent(caption: var_caption);
  }

  @protected
  FfiMessageMetaData sse_decode_ffi_message_meta_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chatType = sse_decode_ffi_chat_type(deserializer);
    var var_targetId = sse_decode_i_64(deserializer);
    var var_msgTypeVal = sse_decode_i_32(deserializer);
    var var_senderUid = sse_decode_i_64(deserializer);
    var var_senderNickName = sse_decode_String(deserializer);
    var var_senderAvatar = sse_decode_opt_String(deserializer);
    var var_msgId = sse_decode_i_64(deserializer);
    var var_sendTime = sse_decode_i_64(deserializer);
    var var_content = sse_decode_list_prim_u_8_strict(deserializer);
    return FfiMessageMetaData(
      chatType: var_chatType,
      targetId: var_targetId,
      msgTypeVal: var_msgTypeVal,
      senderUid: var_senderUid,
      senderNickName: var_senderNickName,
      senderAvatar: var_senderAvatar,
      msgId: var_msgId,
      sendTime: var_sendTime,
      content: var_content,
    );
  }

  @protected
  FfiMessageModel sse_decode_ffi_message_model(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_common = sse_decode_ffi_common_message_model(deserializer);
    var var_contentObj = sse_decode_opt_String(deserializer);
    var var_senderUser = sse_decode_ffi_message_user(deserializer);
    var var_refObj = sse_decode_opt_box_autoadd_ffi_reference_obj(deserializer);
    var var_isSendByMe = sse_decode_bool(deserializer);
    var var_isRead = sse_decode_bool(deserializer);
    var var_status = sse_decode_ffi_msg_status(deserializer);
    return FfiMessageModel(
      common: var_common,
      contentObj: var_contentObj,
      senderUser: var_senderUser,
      refObj: var_refObj,
      isSendByMe: var_isSendByMe,
      isRead: var_isRead,
      status: var_status,
    );
  }

  @protected
  FfiMessageUser sse_decode_ffi_message_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_senderUid = sse_decode_i_64(deserializer);
    var var_senderNickName = sse_decode_String(deserializer);
    var var_senderAvatar = sse_decode_opt_String(deserializer);
    var var_remarkName = sse_decode_String(deserializer);
    return FfiMessageUser(
      senderUid: var_senderUid,
      senderNickName: var_senderNickName,
      senderAvatar: var_senderAvatar,
      remarkName: var_remarkName,
    );
  }

  @protected
  FfiMsgContent sse_decode_ffi_msg_content(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_ffi_text_message_content(
          deserializer,
        );
        return FfiMsgContent_Text(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_ffi_image_message_content(
          deserializer,
        );
        return FfiMsgContent_Image(var_field0);
      case 2:
        var var_field0 =
            sse_decode_box_autoadd_ffi_dynamic_image_message_content(
              deserializer,
            );
        return FfiMsgContent_Image2(var_field0);
      case 3:
        var var_field0 = sse_decode_box_autoadd_ffi_audio_message_content(
          deserializer,
        );
        return FfiMsgContent_Audio(var_field0);
      case 4:
        var var_field0 = sse_decode_box_autoadd_ffi_video_message_content(
          deserializer,
        );
        return FfiMsgContent_Video(var_field0);
      case 5:
        var var_field0 = sse_decode_box_autoadd_ffi_file_message_content(
          deserializer,
        );
        return FfiMsgContent_File(var_field0);
      case 6:
        var var_field0 = sse_decode_box_autoadd_ffi_name_card_message_content(
          deserializer,
        );
        return FfiMsgContent_Card(var_field0);
      case 7:
        var var_field0 = sse_decode_box_autoadd_ffi_system_message_content(
          deserializer,
        );
        return FfiMsgContent_System(var_field0);
      case 8:
        var var_field0 = sse_decode_box_autoadd_ffi_dice_message_content(
          deserializer,
        );
        return FfiMsgContent_Dice(var_field0);
      case 9:
        var var_field0 = sse_decode_box_autoadd_ffi_notice_message_content(
          deserializer,
        );
        return FfiMsgContent_Notice(var_field0);
      case 10:
        var var_field0 = sse_decode_box_autoadd_ffi_location_message_content(
          deserializer,
        );
        return FfiMsgContent_Location(var_field0);
      case 11:
        var var_field0 = sse_decode_box_autoadd_ffi_red_packet_message_content(
          deserializer,
        );
        return FfiMsgContent_Packet(var_field0);
      case 12:
        var var_field0 =
            sse_decode_box_autoadd_ffi_chat_transfer_message_content(
              deserializer,
            );
        return FfiMsgContent_Transfer(var_field0);
      case 13:
        var var_field0 =
            sse_decode_box_autoadd_ffi_medias_caption_message_content(
              deserializer,
            );
        return FfiMsgContent_Medias(var_field0);
      case 14:
        var var_field0 = sse_decode_box_autoadd_ffi_anmated_message_content(
          deserializer,
        );
        return FfiMsgContent_Game(var_field0);
      case 15:
        var var_field0 = sse_decode_box_autoadd_ffi_html_message_content(
          deserializer,
        );
        return FfiMsgContent_Html(var_field0);
      case 16:
        var var_field0 = sse_decode_box_autoadd_ffi_html_2_message_content(
          deserializer,
        );
        return FfiMsgContent_Html2(var_field0);
      case 17:
        var var_field0 = sse_decode_box_autoadd_ffi_group_event_message_content(
          deserializer,
        );
        return FfiMsgContent_GroupEvent(var_field0);
      case 18:
        var var_field0 = sse_decode_box_autoadd_ffi_unknown_message_content(
          deserializer,
        );
        return FfiMsgContent_Unknown(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FfiMsgStatus sse_decode_ffi_msg_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FfiMsgStatus.values[inner];
  }

  @protected
  FfiMsgType sse_decode_ffi_msg_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FfiMsgType.values[inner];
  }

  @protected
  FfiNameCardMessageContent sse_decode_ffi_name_card_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_i_64(deserializer);
    var var_nickName = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_identify = sse_decode_String(deserializer);
    return FfiNameCardMessageContent(
      uid: var_uid,
      nickName: var_nickName,
      icon: var_icon,
      identify: var_identify,
    );
  }

  @protected
  FfiNoticeMessageContent sse_decode_ffi_notice_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_String(deserializer);
    var var_noticeId = sse_decode_i_64(deserializer);
    var var_showNotify = sse_decode_bool(deserializer);
    return FfiNoticeMessageContent(
      content: var_content,
      noticeId: var_noticeId,
      showNotify: var_showNotify,
    );
  }

  @protected
  FfiPushNotificationType sse_decode_ffi_push_notification_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FfiPushNotificationType.values[inner];
  }

  @protected
  FfiRedPacketMessageContent sse_decode_ffi_red_packet_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_redPacketId = sse_decode_String(deserializer);
    var var_status = sse_decode_i_32(deserializer);
    var var_expiredTime = sse_decode_i_64(deserializer);
    var var_type = sse_decode_i_32(deserializer);
    var var_count = sse_decode_i_32(deserializer);
    var var_receiverId = sse_decode_i_64(deserializer);
    var var_receiverName = sse_decode_String(deserializer);
    var var_issuerUid = sse_decode_i_64(deserializer);
    var var_issuerName = sse_decode_String(deserializer);
    var var_issuerIcon = sse_decode_String(deserializer);
    var var_luckyWord = sse_decode_String(deserializer);
    var var_luckyImageUrl = sse_decode_String(deserializer);
    var var_openedCoverUrl = sse_decode_String(deserializer);
    var var_unOpenedCoverUrl = sse_decode_String(deserializer);
    var var_coverExpireTime = sse_decode_i_64(deserializer);
    var var_plusOneWithhold = sse_decode_i_32(deserializer);
    return FfiRedPacketMessageContent(
      redPacketId: var_redPacketId,
      status: var_status,
      expiredTime: var_expiredTime,
      type: var_type,
      count: var_count,
      receiverId: var_receiverId,
      receiverName: var_receiverName,
      issuerUid: var_issuerUid,
      issuerName: var_issuerName,
      issuerIcon: var_issuerIcon,
      luckyWord: var_luckyWord,
      luckyImageUrl: var_luckyImageUrl,
      openedCoverUrl: var_openedCoverUrl,
      unOpenedCoverUrl: var_unOpenedCoverUrl,
      coverExpireTime: var_coverExpireTime,
      plusOneWithhold: var_plusOneWithhold,
    );
  }

  @protected
  FfiReferenceObj sse_decode_ffi_reference_obj(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msgId = sse_decode_i_64(deserializer);
    var var_content = sse_decode_String(deserializer);
    var var_msgType = sse_decode_ffi_msg_type(deserializer);
    var var_uid = sse_decode_i_64(deserializer);
    var var_nickname = sse_decode_String(deserializer);
    return FfiReferenceObj(
      msgId: var_msgId,
      content: var_content,
      msgType: var_msgType,
      uid: var_uid,
      nickname: var_nickname,
    );
  }

  @protected
  FfiRegResponse sse_decode_ffi_reg_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_user = sse_decode_opt_box_autoadd_ffi_user_base(deserializer);
    var var_sessionId = sse_decode_String(deserializer);
    var var_urls = sse_decode_opt_box_autoadd_ffi_url_info(deserializer);
    var var_serverTime = sse_decode_i_64(deserializer);
    var var_token = sse_decode_String(deserializer);
    var var_inviteCode = sse_decode_String(deserializer);
    var var_keyVersion = sse_decode_i_32(deserializer);
    return FfiRegResponse(
      user: var_user,
      sessionId: var_sessionId,
      urls: var_urls,
      serverTime: var_serverTime,
      token: var_token,
      inviteCode: var_inviteCode,
      keyVersion: var_keyVersion,
    );
  }

  @protected
  FfiSystemMessageContent sse_decode_ffi_system_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_String(deserializer);
    return FfiSystemMessageContent(content: var_content);
  }

  @protected
  FfiTextMessageContent sse_decode_ffi_text_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_text = sse_decode_String(deserializer);
    return FfiTextMessageContent(text: var_text);
  }

  @protected
  FfiUnknownMessageContent sse_decode_ffi_unknown_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rawMsgType = sse_decode_i_32(deserializer);
    var var_rawContent = sse_decode_String(deserializer);
    return FfiUnknownMessageContent(
      rawMsgType: var_rawMsgType,
      rawContent: var_rawContent,
    );
  }

  @protected
  FfiUrlInfo sse_decode_ffi_url_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_biz = sse_decode_String(deserializer);
    var var_session = sse_decode_String(deserializer);
    var var_friend = sse_decode_String(deserializer);
    var var_group = sse_decode_String(deserializer);
    var var_staticMap = sse_decode_String(deserializer);
    var var_download = sse_decode_String(deserializer);
    var var_login = sse_decode_String(deserializer);
    var var_config = sse_decode_String(deserializer);
    var var_wss = sse_decode_String(deserializer);
    var var_socketProtocol = sse_decode_i_32(deserializer);
    var var_uploadServer = sse_decode_i_32(deserializer);
    var var_uploadUrl = sse_decode_String(deserializer);
    var var_walletUrl = sse_decode_String(deserializer);
    var var_newsUrl = sse_decode_String(deserializer);
    var var_otcUrl = sse_decode_String(deserializer);
    var var_redPacketUrl = sse_decode_String(deserializer);
    var var_paymentUrl = sse_decode_String(deserializer);
    return FfiUrlInfo(
      biz: var_biz,
      session: var_session,
      friend: var_friend,
      group: var_group,
      staticMap: var_staticMap,
      download: var_download,
      login: var_login,
      config: var_config,
      wss: var_wss,
      socketProtocol: var_socketProtocol,
      uploadServer: var_uploadServer,
      uploadUrl: var_uploadUrl,
      walletUrl: var_walletUrl,
      newsUrl: var_newsUrl,
      otcUrl: var_otcUrl,
      redPacketUrl: var_redPacketUrl,
      paymentUrl: var_paymentUrl,
    );
  }

  @protected
  FfiUser sse_decode_ffi_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_i_64(deserializer);
    var var_nickName = sse_decode_opt_String(deserializer);
    var var_icon = sse_decode_opt_String(deserializer);
    var var_privacy = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_gender = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_signature = sse_decode_opt_String(deserializer);
    var var_viewType = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_language = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_clearTime = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_identify = sse_decode_opt_String(deserializer);
    var var_phone = sse_decode_opt_String(deserializer);
    var var_email = sse_decode_opt_String(deserializer);
    return FfiUser(
      uid: var_uid,
      nickName: var_nickName,
      icon: var_icon,
      privacy: var_privacy,
      gender: var_gender,
      signature: var_signature,
      viewType: var_viewType,
      language: var_language,
      clearTime: var_clearTime,
      identify: var_identify,
      phone: var_phone,
      email: var_email,
    );
  }

  @protected
  FfiUserBase sse_decode_ffi_user_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_i_64(deserializer);
    var var_nickName = sse_decode_String(deserializer);
    var var_avatar = sse_decode_String(deserializer);
    return FfiUserBase(
      uid: var_uid,
      nickName: var_nickName,
      avatar: var_avatar,
    );
  }

  @protected
  FfiVideoMessageContent sse_decode_ffi_video_message_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_fileSize = sse_decode_i_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_thumbUrl = sse_decode_String(deserializer);
    var var_duration = sse_decode_i_32(deserializer);
    return FfiVideoMessageContent(
      width: var_width,
      height: var_height,
      fileSize: var_fileSize,
      url: var_url,
      thumbUrl: var_thumbUrl,
      duration: var_duration,
    );
  }

  @protected
  FileOverwritePolicy sse_decode_file_overwrite_policy(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FileOverwritePolicy.values[inner];
  }

  @protected
  FriendRelation sse_decode_friend_relation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bfFriend = sse_decode_bool(deserializer);
    var var_remarkName = sse_decode_String(deserializer);
    return FriendRelation(bfFriend: var_bfFriend, remarkName: var_remarkName);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<DownloadResult> sse_decode_list_download_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DownloadResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_download_result(deserializer));
    }
    return ans_;
  }

  @protected
  List<DownloadTask> sse_decode_list_download_task(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DownloadTask>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_download_task(deserializer));
    }
    return ans_;
  }

  @protected
  List<DownloadTaskEnhanced> sse_decode_list_download_task_enhanced(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DownloadTaskEnhanced>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_download_task_enhanced(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiAnimatedGameConfig> sse_decode_list_ffi_animated_game_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiAnimatedGameConfig>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_animated_game_config(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiChannelModel> sse_decode_list_ffi_channel_model(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiChannelModel>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_channel_model(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiContactDetail> sse_decode_list_ffi_contact_detail(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiContactDetail>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_contact_detail(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiConversation> sse_decode_list_ffi_conversation(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiConversation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_conversation(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiEmoticonBase> sse_decode_list_ffi_emoticon_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiEmoticonBase>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_emoticon_base(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiGroupBase> sse_decode_list_ffi_group_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiGroupBase>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_group_base(deserializer));
    }
    return ans_;
  }

  @protected
  List<FfiMessageModel> sse_decode_list_ffi_message_model(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiMessageModel>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_message_model(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(FfiChatType, PlatformInt64)> sse_decode_list_record_ffi_chat_type_i_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(FfiChatType, PlatformInt64)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_ffi_chat_type_i_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  MessageError sse_decode_message_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return MessageError(message: var_message);
  }

  @protected
  Map<String, String>? sse_decode_opt_Map_String_String_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Map_String_String_None(deserializer));
    } else {
      return null;
    }
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiChannelModel? sse_decode_opt_box_autoadd_ffi_channel_model(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_channel_model(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiChatType? sse_decode_opt_box_autoadd_ffi_chat_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_chat_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiConversation? sse_decode_opt_box_autoadd_ffi_conversation(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_conversation(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiGroupBase? sse_decode_opt_box_autoadd_ffi_group_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_group_base(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiReferenceObj? sse_decode_opt_box_autoadd_ffi_reference_obj(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_reference_obj(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiUrlInfo? sse_decode_opt_box_autoadd_ffi_url_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_url_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiUserBase? sse_decode_opt_box_autoadd_ffi_user_base(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_user_base(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FriendRelation? sse_decode_opt_box_autoadd_friend_relation(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_friend_relation(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UserBase? sse_decode_opt_box_autoadd_user_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_user_base(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UserOnOrOffLine? sse_decode_opt_box_autoadd_user_on_or_off_line(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_user_on_or_off_line(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (FfiChatType, PlatformInt64) sse_decode_record_ffi_chat_type_i_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_ffi_chat_type(deserializer);
    var var_field1 = sse_decode_i_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, FfiReferenceObj?)
  sse_decode_record_string_opt_box_autoadd_ffi_reference_obj(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_opt_box_autoadd_ffi_reference_obj(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  Rust2ClientMessagePayload sse_decode_rust_2_client_message_payload(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageType = sse_decode_rust_2_client_message_type(deserializer);
    var var_payload = sse_decode_String(deserializer);
    return Rust2ClientMessagePayload(
      messageType: var_messageType,
      payload: var_payload,
    );
  }

  @protected
  Rust2ClientMessageType sse_decode_rust_2_client_message_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Rust2ClientMessageType.values[inner];
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserBase sse_decode_user_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_i_64(deserializer);
    var var_nickName = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_gender = sse_decode_i_32(deserializer);
    var var_friendRelation = sse_decode_opt_box_autoadd_friend_relation(
      deserializer,
    );
    var var_userOnOrOffline = sse_decode_opt_box_autoadd_user_on_or_off_line(
      deserializer,
    );
    var var_signature = sse_decode_String(deserializer);
    var var_depict = sse_decode_String(deserializer);
    var var_bfCancel = sse_decode_bool(deserializer);
    var var_bfBanned = sse_decode_bool(deserializer);
    var var_identify = sse_decode_String(deserializer);
    var var_realName = sse_decode_String(deserializer);
    var var_idNumber = sse_decode_String(deserializer);
    var var_createTime = sse_decode_i_64(deserializer);
    var var_userType = sse_decode_i_32(deserializer);
    return UserBase(
      uid: var_uid,
      nickName: var_nickName,
      icon: var_icon,
      gender: var_gender,
      friendRelation: var_friendRelation,
      userOnOrOffline: var_userOnOrOffline,
      signature: var_signature,
      depict: var_depict,
      bfCancel: var_bfCancel,
      bfBanned: var_bfBanned,
      identify: var_identify,
      realName: var_realName,
      idNumber: var_idNumber,
      createTime: var_createTime,
      userType: var_userType,
    );
  }

  @protected
  UserOnOrOffLine sse_decode_user_on_or_off_line(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_i_64(deserializer);
    var var_online = sse_decode_bool(deserializer);
    var var_createTime = sse_decode_i_64(deserializer);
    var var_bfShow = sse_decode_bool(deserializer);
    return UserOnOrOffLine(
      uid: var_uid,
      online: var_online,
      createTime: var_createTime,
      bfShow: var_bfShow,
    );
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
    ArcFfiMessageContentTrait self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcFfiMessageContentTraitImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void sse_encode_Map_String_String_None(
    Map<String, String> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcdynFfiMessageContentTrait(
    ArcFfiMessageContentTrait self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcFfiMessageContentTraitImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_String_Sse(
    RustStreamSink<String> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_ffi_user_Sse(
    RustStreamSink<FfiUser> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_ffi_user,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_rust_2_client_message_payload_Sse(
    RustStreamSink<Rust2ClientMessagePayload> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_rust_2_client_message_payload,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_account_type(AccountType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_contacts_detail_base(
    ContactsDetailBase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_contacts_detail_base(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_contacts_param(
    ContactsParam self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_contacts_param(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_anmated_message_content(
    FfiAnmatedMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_anmated_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_audio_message_content(
    FfiAudioMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_audio_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_channel_model(
    FfiChannelModel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_channel_model(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_chat_transfer_message_content(
    FfiChatTransferMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_chat_transfer_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_chat_type(
    FfiChatType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_chat_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_client_info(
    FfiClientInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_client_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_conversation(
    FfiConversation self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_conversation(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_dice_message_content(
    FfiDiceMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_dice_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_dynamic_image_message_content(
    FfiDynamicImageMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_dynamic_image_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_file_message_content(
    FfiFileMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_file_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_group_base(
    FfiGroupBase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_group_base(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_group_event_message_content(
    FfiGroupEventMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_group_event_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_html_2_message_content(
    FfiHtml2MessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_html_2_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_html_message_content(
    FfiHtmlMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_html_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_image_message_content(
    FfiImageMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_image_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_init_params(
    FfiInitParams self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_init_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_location_message_content(
    FfiLocationMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_location_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_medias_caption_message_content(
    FfiMediasCaptionMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_medias_caption_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_message_meta_data(
    FfiMessageMetaData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_message_meta_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_message_model(
    FfiMessageModel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_message_model(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_msg_content(
    FfiMsgContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_msg_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_name_card_message_content(
    FfiNameCardMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_name_card_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_notice_message_content(
    FfiNoticeMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_notice_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_red_packet_message_content(
    FfiRedPacketMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_red_packet_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_reference_obj(
    FfiReferenceObj self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_reference_obj(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_system_message_content(
    FfiSystemMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_system_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_text_message_content(
    FfiTextMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_text_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_unknown_message_content(
    FfiUnknownMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_unknown_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_url_info(
    FfiUrlInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_url_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_user(FfiUser self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_user(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_user_base(
    FfiUserBase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_user_base(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_video_message_content(
    FfiVideoMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_video_message_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_friend_relation(
    FriendRelation self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_friend_relation(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
    PlatformInt64 self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_base(
    UserBase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_base(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_on_or_off_line(
    UserOnOrOffLine self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_on_or_off_line(self, serializer);
  }

  @protected
  void sse_encode_contact_order_type(
    ContactOrderType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_contacts_detail_base(
    ContactsDetailBase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_user_base(self.userInfo, serializer);
    sse_encode_String(self.depict, serializer);
    sse_encode_bool(self.bfStar, serializer);
    sse_encode_bool(self.bfDisturb, serializer);
    sse_encode_bool(self.bfMyBlack, serializer);
    sse_encode_String(self.letter, serializer);
    sse_encode_bool(self.bfTop, serializer);
    sse_encode_bool(self.bfVerify, serializer);
    sse_encode_String(self.signature, serializer);
    sse_encode_String(self.groupNickName, serializer);
    sse_encode_String(self.phone, serializer);
    sse_encode_bool(self.bfReadCancel, serializer);
    sse_encode_i_32(self.msgCancelTime, serializer);
    sse_encode_bool(self.bfScreenshot, serializer);
    sse_encode_i_32(self.commonGroupNum, serializer);
    sse_encode_bool(self.bfReadReceipt, serializer);
    sse_encode_i_32(self.groupShutupTime, serializer);
    sse_encode_i_32(self.searchType, serializer);
    sse_encode_String(self.addToken, serializer);
    sse_encode_bool(self.bfIdSearch, serializer);
  }

  @protected
  void sse_encode_contacts_operator(
    ContactsOperator self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_contacts_param(ContactsParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.contactsId, serializer);
    sse_encode_String(self.noteName, serializer);
    sse_encode_String(self.depict, serializer);
    sse_encode_bool(self.bfStar, serializer);
    sse_encode_bool(self.bfDisturb, serializer);
    sse_encode_bool(self.bfTop, serializer);
    sse_encode_bool(self.bfReadCancel, serializer);
    sse_encode_i_32(self.msgCancelTime, serializer);
    sse_encode_bool(self.bfScreenshot, serializer);
  }

  @protected
  void sse_encode_download_progress_info(
    DownloadProgressInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.downloadedBytes, serializer);
    sse_encode_opt_box_autoadd_i_64(self.totalBytes, serializer);
    sse_encode_f_64(self.progressPercentage, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_download_result(
    DownloadResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_String(self.filePath, serializer);
    sse_encode_opt_String(self.errorMessage, serializer);
    sse_encode_i_64(self.fileSize, serializer);
    sse_encode_bool(self.wasDecompressed, serializer);
    sse_encode_bool(self.wasSkipped, serializer);
    sse_encode_u_64(self.downloadDurationMs, serializer);
    sse_encode_opt_String(self.fileHash, serializer);
  }

  @protected
  void sse_encode_download_task(DownloadTask self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_download_type(self.downloadType, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.endpoint, serializer);
    sse_encode_String(self.savePath, serializer);
    sse_encode_bool(self.autoUnzip, serializer);
    sse_encode_opt_Map_String_String_None(self.customHeaders, serializer);
  }

  @protected
  void sse_encode_download_task_enhanced(
    DownloadTaskEnhanced self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_download_type(self.downloadType, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.endpoint, serializer);
    sse_encode_String(self.savePath, serializer);
    sse_encode_bool(self.autoUnzip, serializer);
    sse_encode_opt_Map_String_String_None(self.customHeaders, serializer);
    sse_encode_file_overwrite_policy(self.overwritePolicy, serializer);
    sse_encode_bool(self.calculateHash, serializer);
  }

  @protected
  void sse_encode_download_type(DownloadType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_ffi_animated_game_config(
    FfiAnimatedGameConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.gameId, serializer);
    sse_encode_String(self.gameName, serializer);
    sse_encode_bool(self.isDisplay, serializer);
    sse_encode_String(self.downUrl, serializer);
    sse_encode_String(self.iconName, serializer);
    sse_encode_String(self.startGifName, serializer);
    sse_encode_String(self.repeatGifName, serializer);
    sse_encode_String(self.resultGifName, serializer);
    sse_encode_f_64(self.width, serializer);
    sse_encode_f_64(self.height, serializer);
  }

  @protected
  void sse_encode_ffi_anmated_message_content(
    FfiAnmatedMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.gameId, serializer);
    sse_encode_String(self.currentImage, serializer);
  }

  @protected
  void sse_encode_ffi_audio_message_content(
    FfiAudioMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.duration, serializer);
    sse_encode_i_64(self.fileSize, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.waveData, serializer);
  }

  @protected
  void sse_encode_ffi_channel_model(
    FfiChannelModel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.channelId, serializer);
    sse_encode_String(self.channelName, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_String(self.logoColor, serializer);
    sse_encode_opt_box_autoadd_i_32(self.adminPrivacy, serializer);
    sse_encode_opt_box_autoadd_i_64(self.createTime, serializer);
    sse_encode_opt_box_autoadd_i_32(self.rateLimit, serializer);
    sse_encode_opt_box_autoadd_i_32(self.unit, serializer);
  }

  @protected
  void sse_encode_ffi_chat_transfer_message_content(
    FfiChatTransferMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.transferNo, serializer);
    sse_encode_String(self.count, serializer);
    sse_encode_String(self.coinName, serializer);
    sse_encode_i_32(self.status, serializer);
    sse_encode_i_64(self.expiredTime, serializer);
    sse_encode_i_64(self.receiverId, serializer);
    sse_encode_String(self.receiverName, serializer);
    sse_encode_i_64(self.issuerUid, serializer);
    sse_encode_String(self.issuerName, serializer);
    sse_encode_String(self.issuerIcon, serializer);
    sse_encode_String(self.remark, serializer);
    sse_encode_i_32(self.plusOneWithhold, serializer);
  }

  @protected
  void sse_encode_ffi_chat_type(FfiChatType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ffi_client_info(
    FfiClientInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sessionId, serializer);
    sse_encode_i_32(self.appVer, serializer);
    sse_encode_i_32(self.packageCode, serializer);
    sse_encode_i_32(self.plat, serializer);
    sse_encode_i_32(self.language, serializer);
    sse_encode_String(self.sysMac, serializer);
    sse_encode_String(self.sysModel, serializer);
  }

  @protected
  void sse_encode_ffi_common_message_model(
    FfiCommonMessageModel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.flag, serializer);
    sse_encode_i_64(self.msgId, serializer);
    sse_encode_i_64(self.targetId, serializer);
    sse_encode_ffi_chat_type(self.chatType, serializer);
    sse_encode_String(self.conversationId, serializer);
    sse_encode_ffi_msg_type(self.msgType, serializer);
    sse_encode_i_64(self.sendTime, serializer);
    sse_encode_i_64(self.serverReceiveTime, serializer);
    sse_encode_i_64(self.receiveTime, serializer);
  }

  @protected
  void sse_encode_ffi_contact_detail(
    FfiContactDetail self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.userId, serializer);
    sse_encode_String(self.nickName, serializer);
    sse_encode_String(self.avatar, serializer);
    sse_encode_String(self.depict, serializer);
    sse_encode_bool(self.bfStar, serializer);
    sse_encode_bool(self.bfDisturb, serializer);
    sse_encode_bool(self.bfMyBlack, serializer);
    sse_encode_String(self.letter, serializer);
    sse_encode_bool(self.bfTop, serializer);
    sse_encode_bool(self.bfVerify, serializer);
    sse_encode_String(self.signature, serializer);
    sse_encode_String(self.groupNickName, serializer);
    sse_encode_String(self.phone, serializer);
    sse_encode_bool(self.bfReadCancel, serializer);
    sse_encode_i_32(self.msgCancelTime, serializer);
    sse_encode_bool(self.bfScreenshot, serializer);
    sse_encode_i_32(self.commonGroupNum, serializer);
    sse_encode_bool(self.bfReadReceipt, serializer);
    sse_encode_i_32(self.groupShutupTime, serializer);
    sse_encode_i_32(self.searchType, serializer);
  }

  @protected
  void sse_encode_ffi_conversation(
    FfiConversation self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.conversationId, serializer);
    sse_encode_ffi_chat_type(self.chatType, serializer);
    sse_encode_i_64(self.targetId, serializer);
    sse_encode_String(self.lastMessage, serializer);
    sse_encode_i_64(self.lastMessageTime, serializer);
    sse_encode_ffi_msg_type(self.lastMessageType, serializer);
    sse_encode_i_64(self.senderUid, serializer);
    sse_encode_String(self.senderName, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.avatar, serializer);
    sse_encode_i_32(self.unreadCount, serializer);
    sse_encode_bool(self.isTopPinned, serializer);
    sse_encode_bool(self.isMuted, serializer);
    sse_encode_opt_box_autoadd_i_64(self.topPinnedAt, serializer);
    sse_encode_bool(self.isArchive, serializer);
  }

  @protected
  void sse_encode_ffi_dice_message_content(
    FfiDiceMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.setImageId, serializer);
    sse_encode_i_32(self.imageSize, serializer);
    sse_encode_i_32(self.currentImage, serializer);
  }

  @protected
  void sse_encode_ffi_dynamic_image_message_content(
    FfiDynamicImageMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_i_64(self.fileSize, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.thumbUrl, serializer);
    sse_encode_i_64(self.emoticonId, serializer);
  }

  @protected
  void sse_encode_ffi_emoticon_base(
    FfiEmoticonBase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_emotion_info_type(self.emotionType, serializer);
    sse_encode_String(self.imgName, serializer);
    sse_encode_opt_box_autoadd_i_32(self.gameId, serializer);
    sse_encode_String(self.gameIconPath, serializer);
    sse_encode_String(self.emoticonUrl, serializer);
    sse_encode_i_64(self.emoticonId, serializer);
    sse_encode_f_64(self.width, serializer);
    sse_encode_f_64(self.height, serializer);
  }

  @protected
  void sse_encode_ffi_emoticon_list_result(
    FfiEmoticonListResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ffi_emoticon_base(self.emoticons, serializer);
    sse_encode_i_32(self.count, serializer);
    sse_encode_bool(self.fromCache, serializer);
    sse_encode_u_64(self.lastUpdateTime, serializer);
  }

  @protected
  void sse_encode_ffi_emotion_info_type(
    FfiEmotionInfoType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ffi_file_message_content(
    FfiFileMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.size, serializer);
    sse_encode_String(self.fileUrl, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.mimeType, serializer);
  }

  @protected
  void sse_encode_ffi_get_emoticon_response(
    FfiGetEmoticonResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ffi_emoticon_base(self.emoticons, serializer);
    sse_encode_i_32(self.count, serializer);
    sse_encode_bool(self.fromCache, serializer);
  }

  @protected
  void sse_encode_ffi_group_base(FfiGroupBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.groupId, serializer);
    sse_encode_i_64(self.hostId, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.pic, serializer);
    sse_encode_bool(self.bfJoinCheck, serializer);
    sse_encode_i_64(self.createTime, serializer);
    sse_encode_i_64(self.memberCount, serializer);
    sse_encode_bool(self.bfJoinFriend, serializer);
    sse_encode_bool(self.bfShutup, serializer);
    sse_encode_bool(self.bfGroupReadCancel, serializer);
    sse_encode_i_32(self.groupMsgCancelTime, serializer);
    sse_encode_bool(self.bfBanned, serializer);
    sse_encode_String(self.groupAliasName, serializer);
  }

  @protected
  void sse_encode_ffi_group_detail_response(
    FfiGroupDetailResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_ffi_group_base(self.group, serializer);
    sse_encode_String(self.groupNickName, serializer);
    sse_encode_bool(self.bfTop, serializer);
    sse_encode_bool(self.bfStar, serializer);
    sse_encode_bool(self.bfDisturb, serializer);
    sse_encode_bool(self.bfAddress, serializer);
    sse_encode_i_32(self.memberType, serializer);
    sse_encode_bool(self.bfMember, serializer);
    sse_encode_String(self.qrUrl, serializer);
    sse_encode_i_64(self.qrExpire, serializer);
    sse_encode_bool(self.bfResetQrcode, serializer);
  }

  @protected
  void sse_encode_ffi_group_event_message_content(
    FfiGroupEventMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.rawMsgType, serializer);
    sse_encode_String(self.rawContent, serializer);
  }

  @protected
  void sse_encode_ffi_html_2_message_content(
    FfiHtml2MessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.htmlContent, serializer);
  }

  @protected
  void sse_encode_ffi_html_message_content(
    FfiHtmlMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.htmlContent, serializer);
  }

  @protected
  void sse_encode_ffi_image_message_content(
    FfiImageMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_i_64(self.fileSize, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.thumbUrl, serializer);
    sse_encode_i_32(self.sizeType, serializer);
  }

  @protected
  void sse_encode_ffi_init_params(
    FfiInitParams self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseDir, serializer);
    sse_encode_String(self.secretKeyName, serializer);
    sse_encode_String(self.secretKeyValue, serializer);
    sse_encode_String(self.embedDomianHost, serializer);
    sse_encode_String(self.embedDomainOssUrl, serializer);
    sse_encode_String(self.embedLoginHost, serializer);
    sse_encode_String(self.embedLoginOssUrl, serializer);
  }

  @protected
  void sse_encode_ffi_location_message_content(
    FfiLocationMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.lat, serializer);
    sse_encode_i_64(self.lng, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_ffi_login_response(
    FfiLoginResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_ffi_user_base(self.user, serializer);
    sse_encode_String(self.sessionId, serializer);
    sse_encode_opt_box_autoadd_ffi_url_info(self.urls, serializer);
    sse_encode_i_64(self.serverTime, serializer);
    sse_encode_String(self.token, serializer);
    sse_encode_String(self.inviteCode, serializer);
  }

  @protected
  void sse_encode_ffi_medias_caption_message_content(
    FfiMediasCaptionMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.caption, serializer);
  }

  @protected
  void sse_encode_ffi_message_meta_data(
    FfiMessageMetaData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_chat_type(self.chatType, serializer);
    sse_encode_i_64(self.targetId, serializer);
    sse_encode_i_32(self.msgTypeVal, serializer);
    sse_encode_i_64(self.senderUid, serializer);
    sse_encode_String(self.senderNickName, serializer);
    sse_encode_opt_String(self.senderAvatar, serializer);
    sse_encode_i_64(self.msgId, serializer);
    sse_encode_i_64(self.sendTime, serializer);
    sse_encode_list_prim_u_8_strict(self.content, serializer);
  }

  @protected
  void sse_encode_ffi_message_model(
    FfiMessageModel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_common_message_model(self.common, serializer);
    sse_encode_opt_String(self.contentObj, serializer);
    sse_encode_ffi_message_user(self.senderUser, serializer);
    sse_encode_opt_box_autoadd_ffi_reference_obj(self.refObj, serializer);
    sse_encode_bool(self.isSendByMe, serializer);
    sse_encode_bool(self.isRead, serializer);
    sse_encode_ffi_msg_status(self.status, serializer);
  }

  @protected
  void sse_encode_ffi_message_user(
    FfiMessageUser self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.senderUid, serializer);
    sse_encode_String(self.senderNickName, serializer);
    sse_encode_opt_String(self.senderAvatar, serializer);
    sse_encode_String(self.remarkName, serializer);
  }

  @protected
  void sse_encode_ffi_msg_content(
    FfiMsgContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FfiMsgContent_Text(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ffi_text_message_content(field0, serializer);
      case FfiMsgContent_Image(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ffi_image_message_content(field0, serializer);
      case FfiMsgContent_Image2(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ffi_dynamic_image_message_content(
          field0,
          serializer,
        );
      case FfiMsgContent_Audio(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_ffi_audio_message_content(field0, serializer);
      case FfiMsgContent_Video(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_ffi_video_message_content(field0, serializer);
      case FfiMsgContent_File(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_ffi_file_message_content(field0, serializer);
      case FfiMsgContent_Card(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_ffi_name_card_message_content(
          field0,
          serializer,
        );
      case FfiMsgContent_System(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_ffi_system_message_content(field0, serializer);
      case FfiMsgContent_Dice(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_ffi_dice_message_content(field0, serializer);
      case FfiMsgContent_Notice(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_box_autoadd_ffi_notice_message_content(field0, serializer);
      case FfiMsgContent_Location(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_box_autoadd_ffi_location_message_content(field0, serializer);
      case FfiMsgContent_Packet(field0: final field0):
        sse_encode_i_32(11, serializer);
        sse_encode_box_autoadd_ffi_red_packet_message_content(
          field0,
          serializer,
        );
      case FfiMsgContent_Transfer(field0: final field0):
        sse_encode_i_32(12, serializer);
        sse_encode_box_autoadd_ffi_chat_transfer_message_content(
          field0,
          serializer,
        );
      case FfiMsgContent_Medias(field0: final field0):
        sse_encode_i_32(13, serializer);
        sse_encode_box_autoadd_ffi_medias_caption_message_content(
          field0,
          serializer,
        );
      case FfiMsgContent_Game(field0: final field0):
        sse_encode_i_32(14, serializer);
        sse_encode_box_autoadd_ffi_anmated_message_content(field0, serializer);
      case FfiMsgContent_Html(field0: final field0):
        sse_encode_i_32(15, serializer);
        sse_encode_box_autoadd_ffi_html_message_content(field0, serializer);
      case FfiMsgContent_Html2(field0: final field0):
        sse_encode_i_32(16, serializer);
        sse_encode_box_autoadd_ffi_html_2_message_content(field0, serializer);
      case FfiMsgContent_GroupEvent(field0: final field0):
        sse_encode_i_32(17, serializer);
        sse_encode_box_autoadd_ffi_group_event_message_content(
          field0,
          serializer,
        );
      case FfiMsgContent_Unknown(field0: final field0):
        sse_encode_i_32(18, serializer);
        sse_encode_box_autoadd_ffi_unknown_message_content(field0, serializer);
    }
  }

  @protected
  void sse_encode_ffi_msg_status(FfiMsgStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ffi_msg_type(FfiMsgType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ffi_name_card_message_content(
    FfiNameCardMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.uid, serializer);
    sse_encode_String(self.nickName, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_String(self.identify, serializer);
  }

  @protected
  void sse_encode_ffi_notice_message_content(
    FfiNoticeMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.content, serializer);
    sse_encode_i_64(self.noticeId, serializer);
    sse_encode_bool(self.showNotify, serializer);
  }

  @protected
  void sse_encode_ffi_push_notification_type(
    FfiPushNotificationType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ffi_red_packet_message_content(
    FfiRedPacketMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.redPacketId, serializer);
    sse_encode_i_32(self.status, serializer);
    sse_encode_i_64(self.expiredTime, serializer);
    sse_encode_i_32(self.type, serializer);
    sse_encode_i_32(self.count, serializer);
    sse_encode_i_64(self.receiverId, serializer);
    sse_encode_String(self.receiverName, serializer);
    sse_encode_i_64(self.issuerUid, serializer);
    sse_encode_String(self.issuerName, serializer);
    sse_encode_String(self.issuerIcon, serializer);
    sse_encode_String(self.luckyWord, serializer);
    sse_encode_String(self.luckyImageUrl, serializer);
    sse_encode_String(self.openedCoverUrl, serializer);
    sse_encode_String(self.unOpenedCoverUrl, serializer);
    sse_encode_i_64(self.coverExpireTime, serializer);
    sse_encode_i_32(self.plusOneWithhold, serializer);
  }

  @protected
  void sse_encode_ffi_reference_obj(
    FfiReferenceObj self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.msgId, serializer);
    sse_encode_String(self.content, serializer);
    sse_encode_ffi_msg_type(self.msgType, serializer);
    sse_encode_i_64(self.uid, serializer);
    sse_encode_String(self.nickname, serializer);
  }

  @protected
  void sse_encode_ffi_reg_response(
    FfiRegResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_ffi_user_base(self.user, serializer);
    sse_encode_String(self.sessionId, serializer);
    sse_encode_opt_box_autoadd_ffi_url_info(self.urls, serializer);
    sse_encode_i_64(self.serverTime, serializer);
    sse_encode_String(self.token, serializer);
    sse_encode_String(self.inviteCode, serializer);
    sse_encode_i_32(self.keyVersion, serializer);
  }

  @protected
  void sse_encode_ffi_system_message_content(
    FfiSystemMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.content, serializer);
  }

  @protected
  void sse_encode_ffi_text_message_content(
    FfiTextMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.text, serializer);
  }

  @protected
  void sse_encode_ffi_unknown_message_content(
    FfiUnknownMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.rawMsgType, serializer);
    sse_encode_String(self.rawContent, serializer);
  }

  @protected
  void sse_encode_ffi_url_info(FfiUrlInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.biz, serializer);
    sse_encode_String(self.session, serializer);
    sse_encode_String(self.friend, serializer);
    sse_encode_String(self.group, serializer);
    sse_encode_String(self.staticMap, serializer);
    sse_encode_String(self.download, serializer);
    sse_encode_String(self.login, serializer);
    sse_encode_String(self.config, serializer);
    sse_encode_String(self.wss, serializer);
    sse_encode_i_32(self.socketProtocol, serializer);
    sse_encode_i_32(self.uploadServer, serializer);
    sse_encode_String(self.uploadUrl, serializer);
    sse_encode_String(self.walletUrl, serializer);
    sse_encode_String(self.newsUrl, serializer);
    sse_encode_String(self.otcUrl, serializer);
    sse_encode_String(self.redPacketUrl, serializer);
    sse_encode_String(self.paymentUrl, serializer);
  }

  @protected
  void sse_encode_ffi_user(FfiUser self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.uid, serializer);
    sse_encode_opt_String(self.nickName, serializer);
    sse_encode_opt_String(self.icon, serializer);
    sse_encode_opt_box_autoadd_i_32(self.privacy, serializer);
    sse_encode_opt_box_autoadd_i_32(self.gender, serializer);
    sse_encode_opt_String(self.signature, serializer);
    sse_encode_opt_box_autoadd_i_32(self.viewType, serializer);
    sse_encode_opt_box_autoadd_i_32(self.language, serializer);
    sse_encode_opt_box_autoadd_i_32(self.clearTime, serializer);
    sse_encode_opt_String(self.identify, serializer);
    sse_encode_opt_String(self.phone, serializer);
    sse_encode_opt_String(self.email, serializer);
  }

  @protected
  void sse_encode_ffi_user_base(FfiUserBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.uid, serializer);
    sse_encode_String(self.nickName, serializer);
    sse_encode_String(self.avatar, serializer);
  }

  @protected
  void sse_encode_ffi_video_message_content(
    FfiVideoMessageContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_i_64(self.fileSize, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.thumbUrl, serializer);
    sse_encode_i_32(self.duration, serializer);
  }

  @protected
  void sse_encode_file_overwrite_policy(
    FileOverwritePolicy self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_friend_relation(
    FriendRelation self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.bfFriend, serializer);
    sse_encode_String(self.remarkName, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_download_result(
    List<DownloadResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_download_result(item, serializer);
    }
  }

  @protected
  void sse_encode_list_download_task(
    List<DownloadTask> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_download_task(item, serializer);
    }
  }

  @protected
  void sse_encode_list_download_task_enhanced(
    List<DownloadTaskEnhanced> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_download_task_enhanced(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_animated_game_config(
    List<FfiAnimatedGameConfig> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_animated_game_config(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_channel_model(
    List<FfiChannelModel> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_channel_model(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_contact_detail(
    List<FfiContactDetail> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_contact_detail(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_conversation(
    List<FfiConversation> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_conversation(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_emoticon_base(
    List<FfiEmoticonBase> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_emoticon_base(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_group_base(
    List<FfiGroupBase> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_group_base(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ffi_message_model(
    List<FfiMessageModel> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_message_model(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_ffi_chat_type_i_64(
    List<(FfiChatType, PlatformInt64)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_ffi_chat_type_i_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
    List<(String, String)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_message_error(MessageError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_opt_Map_String_String_None(
    Map<String, String>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Map_String_String_None(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_channel_model(
    FfiChannelModel? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_channel_model(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_chat_type(
    FfiChatType? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_chat_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_conversation(
    FfiConversation? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_conversation(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_group_base(
    FfiGroupBase? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_group_base(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_reference_obj(
    FfiReferenceObj? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_reference_obj(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_url_info(
    FfiUrlInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_url_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_user_base(
    FfiUserBase? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_user_base(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_friend_relation(
    FriendRelation? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_friend_relation(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
    PlatformInt64? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_user_base(
    UserBase? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_user_base(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_user_on_or_off_line(
    UserOnOrOffLine? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_user_on_or_off_line(self, serializer);
    }
  }

  @protected
  void sse_encode_record_ffi_chat_type_i_64(
    (FfiChatType, PlatformInt64) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_chat_type(self.$1, serializer);
    sse_encode_i_64(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_opt_box_autoadd_ffi_reference_obj(
    (String, FfiReferenceObj?) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_opt_box_autoadd_ffi_reference_obj(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
    (String, String) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_rust_2_client_message_payload(
    Rust2ClientMessagePayload self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rust_2_client_message_type(self.messageType, serializer);
    sse_encode_String(self.payload, serializer);
  }

  @protected
  void sse_encode_rust_2_client_message_type(
    Rust2ClientMessageType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_base(UserBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.uid, serializer);
    sse_encode_String(self.nickName, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_i_32(self.gender, serializer);
    sse_encode_opt_box_autoadd_friend_relation(self.friendRelation, serializer);
    sse_encode_opt_box_autoadd_user_on_or_off_line(
      self.userOnOrOffline,
      serializer,
    );
    sse_encode_String(self.signature, serializer);
    sse_encode_String(self.depict, serializer);
    sse_encode_bool(self.bfCancel, serializer);
    sse_encode_bool(self.bfBanned, serializer);
    sse_encode_String(self.identify, serializer);
    sse_encode_String(self.realName, serializer);
    sse_encode_String(self.idNumber, serializer);
    sse_encode_i_64(self.createTime, serializer);
    sse_encode_i_32(self.userType, serializer);
  }

  @protected
  void sse_encode_user_on_or_off_line(
    UserOnOrOffLine self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.uid, serializer);
    sse_encode_bool(self.online, serializer);
    sse_encode_i_64(self.createTime, serializer);
    sse_encode_bool(self.bfShow, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class ArcFfiMessageContentTraitImpl extends RustOpaque
    implements ArcFfiMessageContentTrait {
  // Not to be used by end users
  ArcFfiMessageContentTraitImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcFfiMessageContentTraitImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib
            .instance
            .api
            .rust_arc_increment_strong_count_ArcFfiMessageContentTrait,
    rustArcDecrementStrongCount:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcFfiMessageContentTrait,
    rustArcDecrementStrongCountPtr:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcFfiMessageContentTraitPtr,
  );
}
