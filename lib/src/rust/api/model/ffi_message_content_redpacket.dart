// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'ffi_message_common.dart';
import 'ffi_message_content.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part '../../../../generated/src/rust/api/model/ffi_message_content_redpacket.freezed.dart';
part '../../../../generated/src/rust/api/model/ffi_message_content_redpacket.g.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// 文本消息内容
@freezed
class FfiRedPacketMessageContent with _$FfiRedPacketMessageContent {
  const FfiRedPacketMessageContent._();
  const factory FfiRedPacketMessageContent({
    required String redPacketId,
    required int status,
    required PlatformInt64 expiredTime,
    required int type,
    required int count,
    required PlatformInt64 receiverId,
    required String receiverName,
    required PlatformInt64 issuerUid,
    required String issuerName,
    required String issuerIcon,
    required String luckyWord,
    required String luckyImageUrl,
    required String openedCoverUrl,
    required String unOpenedCoverUrl,
    required PlatformInt64 coverExpireTime,
    required int plusOneWithhold,
  }) = _FfiRedPacketMessageContent;
  static Future<FfiRedPacketMessageContent> default_() =>
      RustLib.instance.api
          .crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentDefault();

  Future<String> ffiToJsonString() => RustLib.instance.api
      .crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToJsonString(
        that: this,
      );

  Future<Uint8List> ffiToProtoData({
    required String contentObj,
    FfiReferenceObj? ffiRefObj,
  }) => RustLib.instance.api
      .crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentFfiToProtoData(
        that: this,
        contentObj: contentObj,
        ffiRefObj: ffiRefObj,
      );

  Future<FfiMsgType> getFfiSubMsgType() => RustLib.instance.api
      .crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentGetFfiSubMsgType(
        that: this,
      );

  Future<void> jsonToFfi({
    required String uniKey,
    required String jsonStr,
  }) => RustLib.instance.api
      .crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentJsonToFfi(
        that: this,
        uniKey: uniKey,
        jsonStr: jsonStr,
      );

  Future<(String, FfiReferenceObj?)> protoDecodeToJson({
    required List<int> content,
  }) => RustLib.instance.api
      .crateApiModelFfiMessageContentRedpacketFfiRedPacketMessageContentProtoDecodeToJson(
        that: this,
        content: content,
      );

  factory FfiRedPacketMessageContent.fromJson(Map<String, dynamic> json) =>
      _$FfiRedPacketMessageContentFromJson(json);
}
