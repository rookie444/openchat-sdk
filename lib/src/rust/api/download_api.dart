// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `calculate_directory_size`, `calculate_file_hash`, `get_documents_directory`, `get_remote_file_size`, `normalize_ios_path`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// 标准HTTP文件下载（增强版）
///
/// # Arguments
/// * `url` - 下载文件的URL
/// * `save_path` - 文件保存路径
/// * `auto_unzip` - 是否自动解压zlib文件
/// * `custom_headers` - 自定义请求头（可选）
/// * `overwrite_policy` - 文件覆盖策略
/// * `calculate_hash` - 是否计算文件MD5哈希值
/// * `extract_to_folder` - ZIP文件是否解压到文件夹（而不是单个文件）
///
/// # Returns
/// * `DownloadResult` - 下载结果信息
Future<DownloadResult> downloadFileHttpEnhanced({
  required String url,
  required String savePath,
  required bool autoUnzip,
  Map<String, String>? customHeaders,
  required FileOverwritePolicy overwritePolicy,
  required bool calculateHash,
  bool? extractToFolder,
}) => RustLib.instance.api.crateApiDownloadApiDownloadFileHttpEnhanced(
  url: url,
  savePath: savePath,
  autoUnzip: autoUnzip,
  customHeaders: customHeaders,
  overwritePolicy: overwritePolicy,
  calculateHash: calculateHash,
  extractToFolder: extractToFolder,
);

/// 标准HTTP文件下载（兼容版本）
///
/// # Arguments
/// * `url` - 下载文件的URL
/// * `save_path` - 文件保存路径
/// * `auto_unzip` - 是否自动解压zlib文件
/// * `custom_headers` - 自定义请求头（可选）
///
/// # Returns
/// * `DownloadResult` - 下载结果信息
Future<DownloadResult> downloadFileHttp({
  required String url,
  required String savePath,
  required bool autoUnzip,
  Map<String, String>? customHeaders,
}) => RustLib.instance.api.crateApiDownloadApiDownloadFileHttp(
  url: url,
  savePath: savePath,
  autoUnzip: autoUnzip,
  customHeaders: customHeaders,
);

/// 加密文件下载
///
/// # Arguments
/// * `base_url` - 服务器基础URL
/// * `endpoint` - API端点
/// * `save_path` - 文件保存路径
/// * `auto_unzip` - 是否自动解压zlib文件
/// * `custom_headers` - 自定义请求头（可选）
/// * `extract_to_folder` - ZIP文件是否解压到文件夹（而不是单个文件）
///
/// # Returns
/// * `DownloadResult` - 下载结果信息
Future<DownloadResult> downloadFileEncryptedApi({
  required String baseUrl,
  required String endpoint,
  required String savePath,
  required bool autoUnzip,
  Map<String, String>? customHeaders,
  bool? extractToFolder,
}) => RustLib.instance.api.crateApiDownloadApiDownloadFileEncryptedApi(
  baseUrl: baseUrl,
  endpoint: endpoint,
  savePath: savePath,
  autoUnzip: autoUnzip,
  customHeaders: customHeaders,
  extractToFolder: extractToFolder,
);

/// 批量文件下载
///
/// # Arguments
/// * `download_tasks` - 下载任务列表
///
/// # Returns
/// * `Vec<DownloadResult>` - 批量下载结果
Future<List<DownloadResult>> downloadFilesBatch({
  required List<DownloadTask> downloadTasks,
}) => RustLib.instance.api.crateApiDownloadApiDownloadFilesBatch(
  downloadTasks: downloadTasks,
);

/// 检查文件是否为zlib格式
Future<bool> isZlibFile({required String filePath}) =>
    RustLib.instance.api.crateApiDownloadApiIsZlibFile(filePath: filePath);

/// 手动解压zlib文件
Future<String> decompressZlibFile({
  required String inputPath,
  String? outputPath,
}) => RustLib.instance.api.crateApiDownloadApiDecompressZlibFile(
  inputPath: inputPath,
  outputPath: outputPath,
);

/// 获取当前平台的Documents目录路径
///
/// 此函数返回当前平台适合存储用户文档的目录路径。
/// 在iOS上，返回应用沙盒中的Documents目录。
/// 在其他平台上，返回用户的Documents文件夹。
///
/// # Returns
/// * `Option<String>` - Documents目录路径，如果无法获取则返回None
Future<String?> getDocumentsDirectoryPath() =>
    RustLib.instance.api.crateApiDownloadApiGetDocumentsDirectoryPath();

/// 规范化文件路径（公开API）
///
/// 此函数将输入路径转换为当前平台上的合适路径。
/// 在iOS上，相对路径会被转换为Documents目录下的绝对路径。
/// 在其他平台上，路径保持不变。
///
/// # Arguments
/// * `path` - 输入路径
///
/// # Returns
/// * `String` - 规范化后的路径
Future<String> normalizeFilePath({required String path}) =>
    RustLib.instance.api.crateApiDownloadApiNormalizeFilePath(path: path);

/// 检查文件是否为ZIP格式（公开API）
///
/// 此函数检查指定文件是否为ZIP格式。
///
/// # Arguments
/// * `file_path` - 文件路径
///
/// # Returns
/// * `Result<bool>` - 成功返回是否为ZIP文件，失败返回错误
Future<bool> isZipFile({required String filePath}) =>
    RustLib.instance.api.crateApiDownloadApiIsZipFile(filePath: filePath);

/// 手动解压ZIP文件（公开API）
///
/// 此函数解压ZIP文件，提取第一个文件到指定路径。
///
/// # Arguments
/// * `input_path` - ZIP文件路径
/// * `output_path` - 输出文件路径（可选，如果为None则自动生成）
///
/// # Returns
/// * `Result<String>` - 成功返回解压后的文件路径，失败返回错误
Future<String> decompressZipFile({
  required String inputPath,
  String? outputPath,
}) => RustLib.instance.api.crateApiDownloadApiDecompressZipFile(
  inputPath: inputPath,
  outputPath: outputPath,
);

/// 批量文件下载（增强版）
///
/// # Arguments
/// * `download_tasks` - 增强下载任务列表
///
/// # Returns
/// * `Vec<DownloadResult>` - 批量下载结果
Future<List<DownloadResult>> downloadFilesBatchEnhanced({
  required List<DownloadTaskEnhanced> downloadTasks,
}) => RustLib.instance.api.crateApiDownloadApiDownloadFilesBatchEnhanced(
  downloadTasks: downloadTasks,
);

/// 监听下载进度
///
/// 返回:
/// * `Stream<String>` - 下载进度事件流 (JSON 格式的 DownloadProgressInfo)
Stream<String> listenForDownloadProgress() =>
    RustLib.instance.api.crateApiDownloadApiListenForDownloadProgress();

/// 文件下载结果
class DownloadResult {
  /// 是否下载成功
  final bool success;

  /// 实际保存的文件路径
  final String filePath;

  /// 错误信息（如果失败）
  final String? errorMessage;

  /// 文件大小（字节）
  final PlatformInt64 fileSize;

  /// 是否进行了解压
  final bool wasDecompressed;

  /// 文件是否已存在（跳过下载）
  final bool wasSkipped;

  /// 下载耗时（毫秒）
  final BigInt downloadDurationMs;

  /// 文件MD5哈希值（如果计算）
  final String? fileHash;

  const DownloadResult({
    required this.success,
    required this.filePath,
    this.errorMessage,
    required this.fileSize,
    required this.wasDecompressed,
    required this.wasSkipped,
    required this.downloadDurationMs,
    this.fileHash,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      filePath.hashCode ^
      errorMessage.hashCode ^
      fileSize.hashCode ^
      wasDecompressed.hashCode ^
      wasSkipped.hashCode ^
      downloadDurationMs.hashCode ^
      fileHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DownloadResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          filePath == other.filePath &&
          errorMessage == other.errorMessage &&
          fileSize == other.fileSize &&
          wasDecompressed == other.wasDecompressed &&
          wasSkipped == other.wasSkipped &&
          downloadDurationMs == other.downloadDurationMs &&
          fileHash == other.fileHash;
}

/// 下载任务
class DownloadTask {
  /// 下载类型
  final DownloadType downloadType;

  /// 文件URL（HTTP下载时使用）
  final String url;

  /// 服务器基础URL（加密下载时使用）
  final String? baseUrl;

  /// API端点（加密下载时使用）
  final String? endpoint;

  /// 文件保存路径
  final String savePath;

  /// 是否自动解压zlib文件
  final bool autoUnzip;

  /// 自定义请求头
  final Map<String, String>? customHeaders;

  const DownloadTask({
    required this.downloadType,
    required this.url,
    this.baseUrl,
    this.endpoint,
    required this.savePath,
    required this.autoUnzip,
    this.customHeaders,
  });

  @override
  int get hashCode =>
      downloadType.hashCode ^
      url.hashCode ^
      baseUrl.hashCode ^
      endpoint.hashCode ^
      savePath.hashCode ^
      autoUnzip.hashCode ^
      customHeaders.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DownloadTask &&
          runtimeType == other.runtimeType &&
          downloadType == other.downloadType &&
          url == other.url &&
          baseUrl == other.baseUrl &&
          endpoint == other.endpoint &&
          savePath == other.savePath &&
          autoUnzip == other.autoUnzip &&
          customHeaders == other.customHeaders;
}

/// 增强下载任务（包含更多选项）
class DownloadTaskEnhanced {
  /// 下载类型
  final DownloadType downloadType;

  /// 文件URL（HTTP下载时使用）
  final String url;

  /// 服务器基础URL（加密下载时使用）
  final String? baseUrl;

  /// API端点（加密下载时使用）
  final String? endpoint;

  /// 文件保存路径
  final String savePath;

  /// 是否自动解压zlib文件
  final bool autoUnzip;

  /// 自定义请求头
  final Map<String, String>? customHeaders;

  /// 文件覆盖策略
  final FileOverwritePolicy overwritePolicy;

  /// 是否计算文件MD5哈希值
  final bool calculateHash;

  const DownloadTaskEnhanced({
    required this.downloadType,
    required this.url,
    this.baseUrl,
    this.endpoint,
    required this.savePath,
    required this.autoUnzip,
    this.customHeaders,
    required this.overwritePolicy,
    required this.calculateHash,
  });

  @override
  int get hashCode =>
      downloadType.hashCode ^
      url.hashCode ^
      baseUrl.hashCode ^
      endpoint.hashCode ^
      savePath.hashCode ^
      autoUnzip.hashCode ^
      customHeaders.hashCode ^
      overwritePolicy.hashCode ^
      calculateHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DownloadTaskEnhanced &&
          runtimeType == other.runtimeType &&
          downloadType == other.downloadType &&
          url == other.url &&
          baseUrl == other.baseUrl &&
          endpoint == other.endpoint &&
          savePath == other.savePath &&
          autoUnzip == other.autoUnzip &&
          customHeaders == other.customHeaders &&
          overwritePolicy == other.overwritePolicy &&
          calculateHash == other.calculateHash;
}

/// 下载类型
enum DownloadType {
  /// 标准HTTP下载
  http,

  /// 加密下载
  encrypted,
}

/// 文件覆盖策略
enum FileOverwritePolicy {
  /// 总是覆盖现有文件
  alwaysOverwrite,

  /// 跳过已存在的文件
  skipExisting,

  /// 只有当文件大小不同时才覆盖
  overwriteIfSizeDifferent,

  /// 询问用户（通过回调）
  ask,
}
